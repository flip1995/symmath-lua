{
	{hidden=false, input="t,x,y,z = vars('t', 'x', 'y', 'z')", output="$t$\9$x$\9$y$\9$z$", outputtype="html", uid=12},
	{hidden=false, input="xs = table{t,x,y,z}", output="table: 0x55ed5ecac930", outputtype="html", uid=55},
	{hidden=false, input="tz, xy = vars('tz', 'xy')", output="$tz$\9$xy$", outputtype="html", uid=8},
	{hidden=false, input="-- upper-case letters map to spinor indexes\nchart_tz_xy = Tensor.Chart{\n\9coords = {tz, xy},\n\9symbols = range(('AZ'):byte(1,2)):mapi(function(ch) return string.char(ch) end):concat(),\n}", output="table: 0x55ed5eadef70", outputtype="html", uid=10},
	{hidden=false, input="-- TODO would be nice to have a set of indexes for any dim, like use with matrices\n-- or would be nice for the Tensor elements to be matrices ...\n-- hmm ....", output="", outputtype="html", uid=62},
	{hidden=false, input="-- lower-case letters map to minkowski indexes\nTensor.Chart{\n\9coords = {t,x,y,z},\n\9symbols = range(('az'):byte(1,2)):mapi(function(ch) return string.char(ch) end):concat(),\n}", output="table: 0x55ed5ec21e40", outputtype="html", uid=11},
	{hidden=false, input="eta = Tensor('_uv', Matrix.diagonal(1,-1,-1,-1):unpack())", output="$\\overset{u\\downarrow v\\rightarrow}{\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& -1& 0& 0\\\\ 0& 0& -1& 0\\\\ 0& 0& 0& -1\\end{array}\\right]}$", outputtype="html", uid=21},
	{hidden=false, input="deltaL = Tensor('_uv', Matrix.diagonal(1,1,1,1):unpack())", output="$\\overset{u\\downarrow v\\rightarrow}{\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]}$", outputtype="html", uid=49},
	{hidden=false, input="deltaU = Tensor('^uv', Matrix.diagonal(1,1,1,1):unpack())", output="$\\overset{u\\downarrow v\\rightarrow}{\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]}$", outputtype="html", uid=50},
	{hidden=false, input="Tensor:findChartForSymbol'a':setMetric(eta)", output="", outputtype="html", uid=23},
	{hidden=false, input="spineps = Tensor('_IJ', {0,1},{-1,0})", output="$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ -1& 0\\end{array}\\right]}$", outputtype="html", uid=20},
	{hidden=false, input="Tensor:findChartForSymbol'I':setMetric(spineps)", output="", outputtype="html", uid=24},
	{hidden=false, input="-- TODO looks like for Matrix with degree>2, MathJax screws up...\nPauliMats = require 'symmath.physics.MatrixBasis'.Pauli4\nprint(PauliMats:unpack());", output="$\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cc} 0& 1\\\\ 1& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cc} 0& -{i}\\\\ i& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cc} 1& 0\\\\ 0& -1\\end{array}\\right]$<br>\n", outputtype="html", uid=1},
	{hidden=false, input="-- TODO as long as there are associated indexes, I should replace any ctor value of an Array subclass with Tensor ...\n--sigmas = Tensor('_u^I_J', PauliMats:unpack())\nsigmas = Tensor('_u^I_J', function(u,I,J) return PauliMats[u][I][J] end)\nprint(sigmas:unpack());", output="$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ 1& 0\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& -{i}\\\\ i& 0\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& -1\\end{array}\\right]}$<br>\n", outputtype="html", uid=2},
	{hidden=false, input="sigmas'_u^I_J'", output="${{{ \\overset{u\\downarrow[{I\\downarrow J\\rightarrow}]}{\\left[\\begin{matrix} \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ 1& 0\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& -{i}\\\\ i& 0\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& -1\\end{array}\\right]}\\end{matrix}\\right]}} _u} ^I} _J$", outputtype="html", uid=18},
	{hidden=false, input="sigmas'_uIJ'()", output="$\\overset{u\\downarrow[{I\\downarrow J\\rightarrow}]}{\\left[\\begin{matrix} \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ -{1}& 0\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& -{1}\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} i& 0\\\\ 0& i\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ -{1}& 0\\end{array}\\right]}\\end{matrix}\\right]}$", outputtype="html", uid=19},
	{hidden=false, input="(epsilon'_IK' * epsilon'^KJ'):eq(spineps'_IK' * spineps'^KJ')()", output="${{{{{ \\epsilon} _I} _K}} {{{{ \\epsilon} ^K} ^J}}} = {\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} -{1}& 0\\\\ 0& -{1}\\end{array}\\right]}}$", outputtype="html", uid=25},
	{hidden=false, input="(epsilon'^IK' * epsilon'_KJ'):eq(spineps'^IK' * spineps'_KJ')()", output="${{{{{ \\epsilon} ^I} ^K}} {{{{ \\epsilon} _K} _J}}} = {\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} -{1}& 0\\\\ 0& -{1}\\end{array}\\right]}}$", outputtype="html", uid=26},
	{hidden=false, input="sigmas[1]'^I_J'", output="${{ \\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}} ^I} _J$", outputtype="html", uid=27},
	{hidden=false, input="epsilon'^I_J':eq(spineps'^I_J')()", output="${{{ \\epsilon} ^I} _J} = {\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}}$", outputtype="html", uid=33},
	{hidden=false, input="epsilon'_I^J':eq(spineps'_I^J')()", output="${{{ \\epsilon} _I} ^J} = {\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} -{1}& 0\\\\ 0& -{1}\\end{array}\\right]}}$", outputtype="html", uid=34},
	{hidden=false, input="(epsilon'_IK' * epsilon'^K_J'):eq(spineps'_IK' * sigmas[1]'^K_J')()", output="${{{{{ \\epsilon} _I} _K}} {{{{ \\epsilon} ^K} _J}}} = {\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ -{1}& 0\\end{array}\\right]}}$", outputtype="html", uid=28},
	{hidden=false, input="(sigmas[1]'^I_J' * sigmas[1]'^K_L')()", output="$\\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}\\end{array}\\right]}$", outputtype="html", uid=4},
	{hidden=false, input="(sigmas[2]'^I_J' * sigmas[2]'^K_L')()", output="$\\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ 1& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ 1& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\end{array}\\right]}$", outputtype="html", uid=15},
	{hidden=false, input="(sigmas[3]'^I_J' * sigmas[3]'^K_L')()", output="$\\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ 1& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ -{1}& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\end{array}\\right]}$", outputtype="html", uid=16},
	{hidden=false, input="(sigmas[4]'^I_J' * sigmas[4]'^K_L')()", output="$\\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& -{1}\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} -{1}& 0\\\\ 0& 1\\end{array}\\right]}\\end{array}\\right]}$", outputtype="html", uid=38},
	{hidden=false, input="-- welp if each sigma squared is I_2x2 and eta's diagonal is +1 -1 -1 -1 <-> trace is -2,\n-- then ofc this will be -2 I_2x2 \n(eta'^uv' * sigmas'_u^I_K' * sigmas'_v^K_J')()", output="$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} -{2}& 0\\\\ 0& -{2}\\end{array}\\right]}$", outputtype="html", uid=39},
	{hidden=false, input="(eta'^uv' * sigmas'_u^I_J' * sigmas'_v^K_L')()", output="$\\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 2\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ -{2}& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& -{2}\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 2& 0\\\\ 0& 0\\end{array}\\right]}\\end{array}\\right]}$", outputtype="html", uid=40},
	{hidden=false, input="spindelta = Tensor('_IJ', Matrix.identity(2):unpack())", output="$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$", outputtype="html", uid=14},
	{hidden=false, input="-- sum over all / recovering coefficients\n(eta'^uv' * sigmas'_u^I_K' * sigmas'_v^K_J')()", output="$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} -{2}& 0\\\\ 0& -{2}\\end{array}\\right]}$", outputtype="html", uid=47},
	{hidden=false, input="(deltaU'^uv' * sigmas'_u^I_K' * sigmas'_v^K_J')()", output="$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 4& 0\\\\ 0& 4\\end{array}\\right]}$", outputtype="html", uid=48},
	{hidden=false, input="--tU = t'^u':makeDense()\n--tU = t'^u':replaceWithDense()\ntU = Tensor('^u', function(u) return var('t^'..({'t','x','y','z'})[u]) end)", output="$\\overset{u\\downarrow}{\\left[\\begin{matrix} {t^{t}} \\\\ {t^{x}} \\\\ {t^{y}} \\\\ {t^{z}}\\end{matrix}\\right]}$", outputtype="html", uid=51},
	{hidden=false, input="(tU'^u' * sigmas'_u^I_J')()", output="$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} {{t^{t}}} + {{t^{z}}}& {{t^{x}}}{-{{{i}} {{{t^{y}}}}}}\\\\ {{t^{x}}} + {{{i}} {{{t^{y}}}}}& {{t^{t}}}{-{{t^{z}}}}\\end{array}\\right]}$", outputtype="html", uid=52},
	{hidden=false, input="(frac(1,2) * tU'^u' * sigmas'_u^I_J' * sigmas'_v^J_I')()", output="$\\overset{v\\downarrow}{\\left[\\begin{matrix} {t^{t}} \\\\ {t^{x}} \\\\ {t^{y}} \\\\ {t^{z}}\\end{matrix}\\right]}$", outputtype="html", uid=53},
	{hidden=false, input="-- supposed to be the Completeness relation identity but ... bleh?\n-- https://en.wikipedia.org/wiki/Pauli_matrices#Completeness_relation_2\n-- is there a math error in wikipedia?\n(2 * delta'_IL' * delta'_JK' - delta'IJ' * delta'_KL')()", output="${-{{{{{ \\delta} ^I} ^J}} {{{{ \\delta} _K} _L}}}} + {{{2}} {{{{ \\delta} _I} _L}} {{{{ \\delta} _J} _K}}}$", outputtype="html", uid=30},
	{hidden=false, input="-- Kulkarni-Nomizu product of two deltas ...\n(spindelta'_IK' * spindelta'_JL' - spindelta'_IL' * spindelta'_JK')():permute'_IJKL'", output="$\\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ -{1}& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ 1& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\end{array}\\right]}$", outputtype="html", uid=32},
	{hidden=false, input="'<hr> ok what about quaternions?'", output="<hr> ok what about quaternions?", outputtype="html", uid=31},
	{hidden=false, input="i2x2 = Matrix({0,-1},{1,0})", output="$\\left[\\begin{array}{cc} 0& -1\\\\ 1& 0\\end{array}\\right]$", outputtype="html", uid=37},
	{hidden=false, input="function complexify(src)\n\9local dim = src:dim()\n\9assert(#dim == 2)\n\9return Matrix:lambda({2*dim[1], 2*dim[2]}, function(i,j)\n\9\9local c = src[math.floor((i-1)/2+1)][math.floor((j-1)/2+1)]\n\9\9local u = (i-1)%2+1\n\9\9local v = (j-1)%2+1\n\9\9return (spindelta[u][v] * Re(c) + i2x2[u][v] * Im(c))()\n\9end)\nend", output="", outputtype="html", uid=59},
	{hidden=false, input="-- sqrt(eta_uv), or maybe inverse-Wick-rotation?\n-- but then the sub-tensors will be Matrix ... TODO fix this\n--local sqrteta  = Tensor('^u_v', Matrix.diagonal(1, i, i, i):unpack())\nsqrteta = Tensor('^u_v', function(u,v) return u==v and (u==1 and 1 or i) or 0 end)", output="$\\overset{u\\downarrow v\\rightarrow}{\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& i& 0& 0\\\\ 0& 0& i& 0\\\\ 0& 0& 0& i\\end{array}\\right]}$", outputtype="html", uid=46},
	{hidden=false, input="local E = var'E'\nlocal EDef = E'^u_v':eq(sqrteta)\nprint(EDef)\n\n-- TODO a downside to using 'i' as a Variable is this ...\n-- TODO 1/i doesn't seem to simplify ...\nlocal sigma = var'sigma'\nlocal sigmaDef = sigma'_u^I_J':eq(sigmas)\n--print(sigmaDef)\nprint(sigmaDef:lhs(), '=', table.unpack(sigmas))\n\nlocal expr = E'^v_u' * sigma'_v^I_J'\nlocal srcMats = expr:subst(EDef:reindex{uv='vu'}, sigmaDef:reindex{u='v'})():permute'_u^I_J'\n--print(expr:eq(srcMats))\nprint(expr, '=', srcMats:unpack())\n\n-- TODO should Tensor have a .transpose() and .T() method? or nah because index valence?\n-- TODO allow transpose and Hermitian to remain unevaluated?  like I already do matrix-multiply and everything else?\nprint[[...then transpose...]]\nprint(expr, '=', srcMats:permute'_uJ^I':unpack())\n\nprint[[...then swap $\\sigma_x$ and $\\sigma_z...$]]\n\nlocal E2 = var\"E'\"\nlocal E2Val = Tensor('^u_v', {1,0,0,0}, {0,0,0,i}, {0,0,i,0}, {0,i,0,0})\nlocal E2Def = E2'^u_v':eq(E2Val)\nprint(E2Def)\n\nlocal expr = E2'^v_u' * sigma'_v^I_J'\nlocal srcMats = expr:subst(E2Def:reindex{uv='vu'}, sigmaDef:reindex{u='v'})():permute'_u_J^I'\n--print(expr:eq(srcMats))\nprint(expr, '=', srcMats:unpack())\n\nprint[[...then perform outer with $1_{2x2}$ or $i_{2x2}$...]]\nquatBasis = table.mapi(srcMats, function(sigma_a, a)\n\9return complexify(sigma_a)\nend)\nprint(expr, [[$\\otimes \\{$]], spindelta,',', i2x2, [[$\\} =$]], quatBasis:unpack())\n\nprint()\nprint[[Here I kept giong to try to turn a matrix-representation into the matrix-multiplicationt-able, but really there's no need for the two to be alike]]\nprint()\n\nquatBasis = quatBasis:mapi(function(m,a)\n\9-- multiply by diag(1,-1,-1,-1)\n\9return (eta * m)():T()\nend)\nprint('(', expr, [[$\\otimes \\{$]], spindelta,',', i2x2, [[$\\} ) \\cdot \\eta =$]], quatBasis:unpack())\n\nprint('(', expr, [[$\\otimes \\{$]], spindelta,',', i2x2, [[$\\} ) \\cdot \\eta \\cdot {diag\\{ 1, i, j, k \\}^j}_k =$]], Array(1, var'i', j, k):dot(quatBasis)())\n;", output="${{{ E} ^u} _v} = {\\overset{u\\downarrow v\\rightarrow}{\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& i& 0& 0\\\\ 0& 0& i& 0\\\\ 0& 0& 0& i\\end{array}\\right]}}$<br>\n${{{ \\sigma} _u} ^I} _J$\9=\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ 1& 0\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& -{i}\\\\ i& 0\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& -1\\end{array}\\right]}$<br>\n${{{{ E} ^v} _u}} {{{{{ \\sigma} _v} ^I} _J}}$\9=\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& i\\\\ i& 0\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ -{1}& 0\\end{array}\\right]}$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} i& 0\\\\ 0& -{i}\\end{array}\\right]}$<br>\n...then transpose...<br>\n${{{{ E} ^v} _u}} {{{{{ \\sigma} _v} ^I} _J}}$\9=\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} 0& i\\\\ i& 0\\end{array}\\right]}$\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ 1& 0\\end{array}\\right]}$\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} i& 0\\\\ 0& -{i}\\end{array}\\right]}$<br>\n...then swap $\\sigma_x$ and $\\sigma_z...$<br>\n${{{ E'} ^u} _v} = {\\overset{u\\downarrow v\\rightarrow}{\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 0& 0& i\\\\ 0& 0& i& 0\\\\ 0& i& 0& 0\\end{array}\\right]}}$<br>\n${{{{ E'} ^v} _u}} {{{{{ \\sigma} _v} ^I} _J}}$\9=\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} i& 0\\\\ 0& -{i}\\end{array}\\right]}$\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ 1& 0\\end{array}\\right]}$\9$\\overset{J\\downarrow I\\rightarrow}{\\left[\\begin{array}{cc} 0& i\\\\ i& 0\\end{array}\\right]}$<br>\n...then perform outer with $1_{2x2}$ or $i_{2x2}$...<br>\n${{{{ E'} ^v} _u}} {{{{{ \\sigma} _v} ^I} _J}}$\9$\\otimes \\{$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9,\9$\\left[\\begin{array}{cc} 0& -1\\\\ 1& 0\\end{array}\\right]$\9$\\} =$\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& -{1}& 0& 0\\\\ 1& 0& 0& 0\\\\ 0& 0& 0& 1\\\\ 0& 0& -{1}& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& -{1}& 0\\\\ 0& 0& 0& -{1}\\\\ 1& 0& 0& 0\\\\ 0& 1& 0& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 0& -{1}\\\\ 0& 0& 1& 0\\\\ 0& -{1}& 0& 0\\\\ 1& 0& 0& 0\\end{array}\\right]$<br>\n<br>\nHere I kept giong to try to turn a matrix-representation into the matrix-multiplicationt-able, but really there's no need for the two to be alike<br>\n<br>\n(\9${{{{ E'} ^v} _u}} {{{{{ \\sigma} _v} ^I} _J}}$\9$\\otimes \\{$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9,\9$\\left[\\begin{array}{cc} 0& -1\\\\ 1& 0\\end{array}\\right]$\9$\\} ) \\cdot \\eta =$\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& -{1}& 0& 0\\\\ 0& 0& -{1}& 0\\\\ 0& 0& 0& -{1}\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 1& 0& 0\\\\ 1& 0& 0& 0\\\\ 0& 0& 0& 1\\\\ 0& 0& -{1}& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 1& 0\\\\ 0& 0& 0& -{1}\\\\ 1& 0& 0& 0\\\\ 0& 1& 0& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 0& 1\\\\ 0& 0& 1& 0\\\\ 0& -{1}& 0& 0\\\\ 1& 0& 0& 0\\end{array}\\right]$<br>\n(\9${{{{ E'} ^v} _u}} {{{{{ \\sigma} _v} ^I} _J}}$\9$\\otimes \\{$\9$\\overset{I\\downarrow J\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}$\9,\9$\\left[\\begin{array}{cc} 0& -1\\\\ 1& 0\\end{array}\\right]$\9$\\} ) \\cdot \\eta \\cdot {diag\\{ 1, i, j, k \\}^j}_k =$\9$\\left[\\begin{array}{cccc} 1& i& j& k\\\\ i& -{1}& k& -{j}\\\\ j& -{k}& -{1}& i\\\\ k& j& -{i}& -{1}\\end{array}\\right]$<br>\n", outputtype="html", uid=35},
	{hidden=false, input="-- how to write complexification / outer with basis of ident and i_2x2 ?", output="", outputtype="html", uid=41},
	{hidden=false, input="--qeUs = Tensor('^u', function(u) return var('e^'..xs[u].name) end)\nqeUs = Tensor('^u', table{'1', 'i', 'j', 'k'}:mapi(function(ch) return var('\\\\mathbf{'..ch..'}') end):unpack())", output="$\\overset{u\\downarrow}{\\left[\\begin{matrix} \\mathbf{1} \\\\ \\mathbf{i} \\\\ \\mathbf{j} \\\\ \\mathbf{k}\\end{matrix}\\right]}$", outputtype="html", uid=54},
	{hidden=false, input="-- how to outer product?\n-- this is an inner ...\n-- (sigmas * spindelta)()\nlocal tmp = (sqrteta'^v_u' * sigmas'_v^I_J')()\n-- this is an outer, but both need to be a Tensor, and indexes need to be provided...\nprint((Re(tmp'_u^I_J') * spindelta'_KL' + Im(tmp'_u^I_J') * Tensor('_KL', i2x2:unpack())'_KL')())\n\nprint\"this still needs to be unraveled / decomplexified from 2x2x2x2 to 4x4 before it is the correct quaternion basis\"\nprint((qeUs'^u' * (Re(tmp'_u^I_J') * spindelta'_KL' + Im(tmp'_u^I_J') * Tensor('_KL', i2x2:unpack())'_KL'))())\n\n;", output="$\\overset{u\\downarrow[{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}]}{\\left[\\begin{matrix} \\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ 1& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ 1& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} -{1}& 0\\\\ 0& -{1}\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\end{array}\\right]} \\\\ \\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& -{1}\\\\ 1& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 0\\\\ 0& 0\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} 0& 1\\\\ -{1}& 0\\end{array}\\right]}\\end{array}\\right]}\\end{matrix}\\right]}$<br>\nthis still needs to be unraveled / decomplexified from 2x2x2x2 to 4x4 before it is the correct quaternion basis<br>\n$\\overset{I\\downarrow J\\rightarrow[{K\\downarrow L\\rightarrow}]}{\\left[\\begin{array}{cc} \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} \\mathbf{1}& -{\\mathbf{k}}\\\\ \\mathbf{k}& \\mathbf{1}\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} \\mathbf{j}& -{\\mathbf{i}}\\\\ \\mathbf{i}& \\mathbf{j}\\end{array}\\right]}\\\\ \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} -{\\mathbf{j}}& -{\\mathbf{i}}\\\\ \\mathbf{i}& -{\\mathbf{j}}\\end{array}\\right]}& \\overset{K\\downarrow L\\rightarrow}{\\left[\\begin{array}{cc} \\mathbf{1}& \\mathbf{k}\\\\ -{\\mathbf{k}}& \\mathbf{1}\\end{array}\\right]}\\end{array}\\right]}$<br>\n", outputtype="html", uid=44},
	{hidden=false, input="-- quaternion basis:\n-- you have to ... \n-- 1) multiply sigma_xyz with 'i'\n-- 2) swap x and z\n-- because Pauli ... smh\nqes = Matrix( range(4):mapi(function(u) return (sqrteta[u][u] * PauliMats[u])() end):unpack() )\nqes[2], qes[4] = qes[4], qes[2]\nprint(qes:unpack());", output="$\\left[\\begin{array}{cc} 1& 0\\\\ 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cc} i& 0\\\\ 0& -{i}\\end{array}\\right]$\9$\\left[\\begin{array}{cc} 0& 1\\\\ -{1}& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cc} 0& i\\\\ i& 0\\end{array}\\right]$<br>\n", outputtype="html", uid=45},
	{hidden=false, input="qe4s = Matrix( range(4):mapi(function(u) return complexify(qes[u]) end):unpack() )\nprint(qe4s:unpack());", output="$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& -{1}& 0& 0\\\\ 1& 0& 0& 0\\\\ 0& 0& 0& 1\\\\ 0& 0& -{1}& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 1& 0\\\\ 0& 0& 0& 1\\\\ -{1}& 0& 0& 0\\\\ 0& -{1}& 0& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 0& -{1}\\\\ 0& 0& 1& 0\\\\ 0& -{1}& 0& 0\\\\ 1& 0& 0& 0\\end{array}\\right]$<br>\n", outputtype="html", uid=60},
	{hidden=false, input="--[=[\n-- TODO this is where factorLinearSystem + unraval comes in handy.  How about a quotient set / linear-combination function? \nlocal function reshape(m)\9-- 2x2 -> 4\n\9return Matrix:lambda({4}, function(u) return m[(u-1)%2+1][math.floor((u-1)/2)+1] end)\nend\n\nlocal qesReshaped = Matrix( range(4):mapi(function(u) return reshape(qes[u]) end):unpack() ):T()\9-- T() so our vectors are columns\nprint'quaternin C^2x2 matrix reshaped to 1x4 as column vectors:'\nprint(qesReshaped)\n\nlocal mulTable = Matrix:lambda({4,4}, function(a,b)\n\9local qc = (qes[a] * qes[b])()\n\9--[[ reshape\n\9local qcReshaped = reshape(qc)\n\9local A, b = factorLinearSystem(qcReshaped, \n\9--]]\n\9-- [[ cheap way to do it\n\9for c=1,4 do\n\9\9if qc == qes[c]() then return qeUs[c] end\n\9\9if qc == (-qes[c])() then return -qeUs[c] end\n\9end\n\9--]]\n\9return qc\nend)\n--]=]\n-- [[ without reshape, just basic +- testing\nfunction makeMulTable(ms, repls, mulOp)\n\9mulOp = mulOp or symmath.op.mul\n\9return Matrix:lambda({#ms,#ms}, function(a,b)\n\9\9local qc = mulOp(ms[a], ms[b])()\n\9\9for _,repl in ipairs(repls) do\n\9\9\9if qc == repl:rhs()() then return repl:lhs() end\n\9\9\9if qc == (-repl:rhs())() then return -repl:lhs() end\n\9\9end\n\9\9return qc\n\9end)\nend\n--]]\n\nlocal mulTableC2 = makeMulTable(qes, range(4):mapi(function(u) return qeUs[u]:eq(qes[u]) end))\nprint[[quaternion $\\mathbb{C}^{2 \\times 2}$ multiplication table:]]\nprint(mulTableC2)\n\nlocal mulTableR4 = makeMulTable(qe4s, range(4):mapi(function(u) return qeUs[u]:eq(qe4s[u]) end))\nprint[[quaternion $\\mathbb{R}^{4 \\times 4}$ multiplication table:]]\nprint(mulTableR4)\n;", output="quaternion $\\mathbb{C}^{2 \\times 2}$ multiplication table:<br>\n$\\left[\\begin{array}{cccc} \\mathbf{1}& \\mathbf{i}& \\mathbf{j}& \\mathbf{k}\\\\ \\mathbf{i}& -{\\mathbf{1}}& \\mathbf{k}& -{\\mathbf{j}}\\\\ \\mathbf{j}& -{\\mathbf{k}}& -{\\mathbf{1}}& \\mathbf{i}\\\\ \\mathbf{k}& \\mathbf{j}& -{\\mathbf{i}}& -{\\mathbf{1}}\\end{array}\\right]$<br>\nquaternion $\\mathbb{R}^{4 \\times 4}$ multiplication table:<br>\n$\\left[\\begin{array}{cccc} \\mathbf{1}& \\mathbf{i}& \\mathbf{j}& \\mathbf{k}\\\\ \\mathbf{i}& -{\\mathbf{1}}& \\mathbf{k}& -{\\mathbf{j}}\\\\ \\mathbf{j}& -{\\mathbf{k}}& -{\\mathbf{1}}& \\mathbf{i}\\\\ \\mathbf{k}& \\mathbf{j}& -{\\mathbf{i}}& -{\\mathbf{1}}\\end{array}\\right]$<br>\n", outputtype="html", uid=56},
	{hidden=false, input="gammas = Tensor('^u', function(u) return var('gamma^'..(u-1)) end)", output="$\\overset{u\\downarrow}{\\left[\\begin{matrix} {\\gamma^{0}} \\\\ {\\gamma^{1}} \\\\ {\\gamma^{2}} \\\\ {\\gamma^{3}}\\end{matrix}\\right]}$", outputtype="html", uid=63},
	{hidden=false, input="DiracMats = require 'symmath.physics.MatrixBasis'.Dirac\nprint(gamma'^u', '=', DiracMats:unpack());", output="${ \\gamma} ^u$\9=\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& -1& 0\\\\ 0& 0& 0& -1\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 0& 1\\\\ 0& 0& 1& 0\\\\ 0& -1& 0& 0\\\\ -1& 0& 0& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 0& -{i}\\\\ 0& 0& i& 0\\\\ 0& i& 0& 0\\\\ -{i}& 0& 0& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 1& 0\\\\ 0& 0& 0& -1\\\\ -1& 0& 0& 0\\\\ 0& 1& 0& 0\\end{array}\\right]$<br>\n", outputtype="html", uid=58},
	{hidden=false, input="print((gamma'^u')^2, '=', range(4):mapi(function(a) return (DiracMats[a]^2)() end):unpack() );", output="${{ \\gamma} ^u}^{2}$\9=\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} -{1}& 0& 0& 0\\\\ 0& -{1}& 0& 0\\\\ 0& 0& -{1}& 0\\\\ 0& 0& 0& -{1}\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} -{1}& 0& 0& 0\\\\ 0& -{1}& 0& 0\\\\ 0& 0& -{1}& 0\\\\ 0& 0& 0& -{1}\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} -{1}& 0& 0& 0\\\\ 0& -{1}& 0& 0\\\\ 0& 0& -{1}& 0\\\\ 0& 0& 0& -{1}\\end{array}\\right]$<br>\n", outputtype="html", uid=65},
	{hidden=false, input="print((gamma'^u')^3, '=', range(4):mapi(function(a) return (DiracMats[a]^3)() end):unpack() );", output="${{ \\gamma} ^u}^{3}$\9=\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& -{1}& 0\\\\ 0& 0& 0& -{1}\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 0& -{1}\\\\ 0& 0& -{1}& 0\\\\ 0& 1& 0& 0\\\\ 1& 0& 0& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& 0& i\\\\ 0& 0& -{i}& 0\\\\ 0& -{i}& 0& 0\\\\ i& 0& 0& 0\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 0& 0& -{1}& 0\\\\ 0& 0& 0& 1\\\\ 1& 0& 0& 0\\\\ 0& -{1}& 0& 0\\end{array}\\right]$<br>\n", outputtype="html", uid=66},
	{hidden=false, input="print((gamma'^u')^4, '=', range(4):mapi(function(a) return (DiracMats[a]^4)() end):unpack() );", output="${{ \\gamma} ^u}^{4}$\9=\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]$\9$\\left[\\begin{array}{cccc} 1& 0& 0& 0\\\\ 0& 1& 0& 0\\\\ 0& 0& 1& 0\\\\ 0& 0& 0& 1\\end{array}\\right]$<br>\n", outputtype="html", uid=67},
	{hidden=false, input="-- TODO for power-of-power, and for power-of-index, make sure to wrap the output with an extra set of parenthesis.\n\n-- welp random fact about the multiplication table, and the powers of gamma matrices:\n-- looks like multiplication between two different gamma matrices doesn't always end up as a gamma matrix (or scalar thereof)\n-- so we need more matrices to make this a group...\n\n-- At least the multiplication table is antisymmetric.\n\nmakeMulTable(DiracMats, table{\n\9var'\\\\mathbf{0}':eq(Matrix:zeros{4,4}),\n\9var'\\\\mathbf{1}':eq(Matrix.identity(4))\n} )", output="$\\left[\\begin{array}{cccc} \\mathbf{1}& \\left[\\begin{array}{cccc} 0& 0& 0& 1\\\\ 0& 0& 1& 0\\\\ 0& 1& 0& 0\\\\ 1& 0& 0& 0\\end{array}\\right]& \\left[\\begin{array}{cccc} 0& 0& 0& -{i}\\\\ 0& 0& i& 0\\\\ 0& -{i}& 0& 0\\\\ i& 0& 0& 0\\end{array}\\right]& \\left[\\begin{array}{cccc} 0& 0& 1& 0\\\\ 0& 0& 0& -{1}\\\\ 1& 0& 0& 0\\\\ 0& -{1}& 0& 0\\end{array}\\right]\\\\ \\left[\\begin{array}{cccc} 0& 0& 0& -{1}\\\\ 0& 0& -{1}& 0\\\\ 0& -{1}& 0& 0\\\\ -{1}& 0& 0& 0\\end{array}\\right]& -{\\mathbf{1}}& \\left[\\begin{array}{cccc} -{i}& 0& 0& 0\\\\ 0& i& 0& 0\\\\ 0& 0& -{i}& 0\\\\ 0& 0& 0& i\\end{array}\\right]& \\left[\\begin{array}{cccc} 0& 1& 0& 0\\\\ -{1}& 0& 0& 0\\\\ 0& 0& 0& 1\\\\ 0& 0& -{1}& 0\\end{array}\\right]\\\\ \\left[\\begin{array}{cccc} 0& 0& 0& i\\\\ 0& 0& -{i}& 0\\\\ 0& i& 0& 0\\\\ -{i}& 0& 0& 0\\end{array}\\right]& \\left[\\begin{array}{cccc} i& 0& 0& 0\\\\ 0& -{i}& 0& 0\\\\ 0& 0& i& 0\\\\ 0& 0& 0& -{i}\\end{array}\\right]& -{\\mathbf{1}}& \\left[\\begin{array}{cccc} 0& -{i}& 0& 0\\\\ -{i}& 0& 0& 0\\\\ 0& 0& 0& -{i}\\\\ 0& 0& -{i}& 0\\end{array}\\right]\\\\ \\left[\\begin{array}{cccc} 0& 0& -{1}& 0\\\\ 0& 0& 0& 1\\\\ -{1}& 0& 0& 0\\\\ 0& 1& 0& 0\\end{array}\\right]& \\left[\\begin{array}{cccc} 0& -{1}& 0& 0\\\\ 1& 0& 0& 0\\\\ 0& 0& 0& -{1}\\\\ 0& 0& 1& 0\\end{array}\\right]& \\left[\\begin{array}{cccc} 0& i& 0& 0\\\\ i& 0& 0& 0\\\\ 0& 0& 0& i\\\\ 0& 0& i& 0\\end{array}\\right]& -{\\mathbf{1}}\\end{array}\\right]$", outputtype="html", uid=61},
	{hidden=false, input="makeMulTable(\n\9DiracMats,\n\9table{\n\9\9var'\\\\mathbf{0}':eq(Matrix:zeros{4,4}),\n\9\9var'\\\\mathbf{1}':eq(Matrix.identity(4))\n\9},\n\9function(a,b) return ((a*b + b*a)/2)() end\n)", output="$\\left[\\begin{array}{cccc} \\mathbf{1}& \\mathbf{0}& \\mathbf{0}& \\mathbf{0}\\\\ \\mathbf{0}& -{\\mathbf{1}}& \\mathbf{0}& \\mathbf{0}\\\\ \\mathbf{0}& \\mathbf{0}& -{\\mathbf{1}}& \\mathbf{0}\\\\ \\mathbf{0}& \\mathbf{0}& \\mathbf{0}& -{\\mathbf{1}}\\end{array}\\right]$", outputtype="html", uid=64},
	{hidden=false, input="", output="", outputtype="html", uid=68}
}