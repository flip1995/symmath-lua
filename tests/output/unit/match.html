<!doctype html>
<html>
	<head>
		<meta charset='utf-8'>
		<title>tests/unit/match</title>
		<script type='text/javascript' src='../tryToFindMathJax.js'></script>
	</head>
	<body onload='tryToFindMathJax();'>

<table border="1" style="border-collapse:collapse">
<tr><td>
<b></b><br>
<code>simplifyAssertEq(x, x)</code>
</td><td>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.398000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertNe(x, y)</code>
</td><td>
${x} \ne {y}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.301000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>assert(x:match(x))</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.019000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code>assert(not x:match(y))</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.011000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>constants</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>implicit mul by 1</b><br>
<code>simplifyAssertAllEq({const(2):match(const(2)*W(1))}, {const(1)})</code>
</td><td>
${1} = {1}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.888000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({const(2):match(const(1)*W(1))}, {const(2)})</code>
</td><td>
${1} = {1}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.253000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b>implicit divide by 1</b><br>
<code>simplifyAssertAllEq({const(2):match(const(2)/W(1))}, {const(1)})</code>
</td><td>
${1} = {1}$
<br>
lhs:	1=false	<br>
rhs:	1=$1$	<br>
when comparing key 1	<br>
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/export/Export.lua:106: attempt to index local 'x' (a boolean value)<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:182: in function '__index'<br>
	/home/chris/Projects/lua/symmath/export/Export.lua:106: in function 'precedence'<br>
	/home/chris/Projects/lua/symmath/export/Export.lua:121: in function 'testWrapStrOfChildWithParenthesis'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:74: in function 'wrapStrOfChildWithParenthesis'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:209: in function 'apply'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:664: in function '__call'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:672: in function 'applyLaTeX'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:715: in function </home/chris/Projects/lua/symmath/export/LaTeX.lua:714><br>
	[C]: in function 'print'<br>
	/home/chris/Projects/lua/symmath/export/MathJax.lua:126: in function 'printbr'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:172: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:168><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:168: in function 'simplifyAssertAllEq'<br>
	[string "simplifyAssertAllEq({const(2):match(const(2)/..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0	21
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: failed<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:247: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:246><br>
	[C]: in function 'error'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: in function 'simplifyAssertAllEq'<br>
	[string "simplifyAssertAllEq({const(2):match(const(2)/..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0
</td><td>
time: 0.501000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b>implicit integer factoring</b><br>
<code>simplifyAssertAllEq({const(4):match(const(2)*W(1))}, {const(2)})</code>
</td><td>
${1} = {1}$
<br>
lhs:	1=false	<br>
rhs:	1=$2$	<br>
when comparing key 1	<br>
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/export/Export.lua:106: attempt to index local 'x' (a boolean value)<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:182: in function '__index'<br>
	/home/chris/Projects/lua/symmath/export/Export.lua:106: in function 'precedence'<br>
	/home/chris/Projects/lua/symmath/export/Export.lua:121: in function 'testWrapStrOfChildWithParenthesis'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:74: in function 'wrapStrOfChildWithParenthesis'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:209: in function 'apply'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:664: in function '__call'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:672: in function 'applyLaTeX'<br>
	/home/chris/Projects/lua/symmath/export/LaTeX.lua:715: in function </home/chris/Projects/lua/symmath/export/LaTeX.lua:714><br>
	[C]: in function 'print'<br>
	/home/chris/Projects/lua/symmath/export/MathJax.lua:126: in function 'printbr'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:172: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:168><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:168: in function 'simplifyAssertAllEq'<br>
	[string "simplifyAssertAllEq({const(4):match(const(2)*..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0	21
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: failed<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:247: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:246><br>
	[C]: in function 'error'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: in function 'simplifyAssertAllEq'<br>
	[string "simplifyAssertAllEq({const(4):match(const(2)*..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0
</td><td>
time: 0.742000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>functions</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({sin(x):match(sin(W(1)))}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.285000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>functions and mul mixed</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({sin(2*x):match(sin(W(1)))}, {2 * x})</code>
</td><td>
${1} = {1}$
<br>
${{{2}} {{x}}} = {{{2}} {{x}}}$
<br>
${{{2}} {{x}}} = {{{2}} {{x}}}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 3.565000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>*:Tidy:apply<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({sin(2*x):match(sin(2 * W(1)))}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.918000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>matching c*f(x) => c*sin(a*x)</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({sin(2*x):match(W{1, dependsOn=x} * W{index=2, cannotDependOn=x})}, {sin(2*x), one})</code>
</td><td>
${2} = {2}$
<br>
${\sin\left( {{{2}} {{x}}}\right)} = {\sin\left( {{{2}} {{x}}}\right)}$
<br>
${\sin\left( {{{2}} {{x}}}\right)} = {\sin\left( {{{2}} {{x}}}\right)}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 5.148000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({sin(2*x):match(sin(W{1, cannotDependOn=x} * x))}, {const(2)})</code>
</td><td>
${1} = {1}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.503000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>add</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({x:match(W{2, cannotDependOn=x} + W{1, dependsOn=x})}, {x, zero})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.828000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Constant:Tidy:apply<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertEq((x + y), (x + y))</code>
</td><td>
${{x} + {y}} = {{x} + {y}}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.805000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>+:Factor:apply<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>assert((x + y):match(x + y))</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.058000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>add match to first term</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(W(1) + y)}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.554000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>add match to second term</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(x + W(1))}, {y})</code>
</td><td>
${1} = {1}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.483000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>change order</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(y + W(1))}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.457000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>add match to zero, because nothing's left</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(x + y + W(1))}, {zero})</code>
</td><td>
${1} = {1}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.453000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(W(1))}, {x + y})</code>
</td><td>
${1} = {1}$
<br>
${{x} + {y}} = {{x} + {y}}$
<br>
${{x} + {y}} = {{x} + {y}}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 2.575000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>+:Factor:apply<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>doubled-up matches should only work if they match</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>assert(not (x + y):match(W(1) + W(1)))</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.412000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>this too, this would work only if x + x and not x + y</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + x):match(W(1) + W(1))}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.351000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>this too</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + x):match(W{1, atMost=1} + W{2, atMost=1})}, {x, x})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.396000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>this should match (x+y), 0</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(W(1) + W(2))}, {x + y, zero})</code>
</td><td>
${2} = {2}$
<br>
${{x} + {y}} = {{x} + {y}}$
<br>
${{x} + {y}} = {{x} + {y}}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 2.048000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>+:Factor:apply<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(W{1, atMost=1} + W{2, atMost=1})}, {x, y})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.662000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>for these to work, I have to add the multi-wildcard stuff to the non-wildcard elements, handled in add.wildcardMatches</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({x:match(W(1) + W(2))}, {x, zero})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.474000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({x:match(x + W(1) + W(2))}, {zero, zero})</code>
</td><td>
${2} = {2}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.534000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({x:match(W(1) + x + W(2))}, {zero, zero})</code>
</td><td>
${2} = {2}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.305000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W(1) + W(2))}, {x * y, zero})</code>
</td><td>
${2} = {2}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.263000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>*:Tidy:apply<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>make sure within add.wildcardMatches we greedy-match any wildcards with 'atLeast' before assigning the rest to zero</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({x:match(W(1) + W{2,atLeast=1} + W(3))}, {zero, x, zero})</code>
</td><td>
${3} = {3}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.791000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>now we match wildcards left-to-right, so the cannot-depend-on will match first</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(W{1, cannotDependOn=x} + W{2, dependsOn=x})}, {y, x})</code>
</td><td>
${2} = {2}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.614000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x + y):match(W{1, cannotDependOn=x, atLeast=1} + W{2, dependsOn=x})}, {y, x})</code>
</td><td>
${2} = {2}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.432000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>same with mul</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(y * W(1))}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.224000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(x * y * W(1))}, {one})</code>
</td><td>
${1} = {1}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.515000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({ (x * y):match(W(1))}, {x * y})</code>
</td><td>
${1} = {1}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 2.330000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>*:Tidy:apply<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>assert(not (x * y):match(W(1) * W(1)))</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.251000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * x):match(W(1) * W(1))}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.396000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>verify wildcards are greedy with multiple mul matching</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>the first will take all expressions, the second gets the empty set</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W(1) * W(2))}, {x * y, one})</code>
</td><td>
${2} = {2}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.866000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>verify 'atMost' works - since both need at least 1 entry, it will only match when each gets a separate term</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * x):match(W{1, atMost=1} * W{2, atMost=1})}, {x, x})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.424000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>verify 'atMost' cooperates with non-atMost wildcards</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W(1) * W{2, atLeast=1})}, {x, y})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.371000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W{1, atMost=1} * W{2, atMost=1})}, {x, y})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.401000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>assert( not( Constant(0):match(x) ) )</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.039000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code>assert( not( Constant(0):match(x * y) ) )</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.071000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertEq( zero:match(W(1) * x), zero )</code>
</td><td>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.164000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code>assert( not zero:match(W{1, dependsOn=x} * x) )</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.044000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertEq( zero:match(W(1) * x * y), zero )</code>
</td><td>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.091000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertEq( one:match(1 + W(1)), zero )</code>
</td><td>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.094000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertEq( one:match(1 + W(1) * x), zero )</code>
</td><td>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.082000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertEq( one:match(1 + W(1) * x * y), zero )</code>
</td><td>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.193000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>how can you take x*y and match only the 'x'?</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W{index=2, cannotDependOn=x} * W{1, dependsOn=x})}, {x, y})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.294000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W{1, dependsOn=x} * W{index=2, cannotDependOn=x})}, {x*y, 1})</code>
</td><td>
${2} = {2}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.006000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W{index=2, cannotDependOn=x} * W(1))}, {x, y})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${y} = {y}$
<br>
${y} = {y}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.423000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W(1) * W{index=2, cannotDependOn=x})}, {x*y, 1})</code>
</td><td>
${2} = {2}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.860000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x * y):match(W(1) * W(2))}, {x*y, 1})</code>
</td><td>
${2} = {2}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${{{x}} {{y}}} = {{{x}} {{y}}}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.663000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>combinations of add and mul</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>for this to work, add.wildcardMatches must call the wildcard-capable objects' own wildcard handlers correctly (and use push/pop match states, instead of assigning to wildcard indexes directly?)</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>also, because add.wildcardMatches assigns the extra wildcards to zero, it will be assigning (W(2) * W(3)) to zero ... which means it must (a) handle mul.wildcardMatches and (b) pick who of mul's children gets the zero and who doesn't</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>it also means that a situation like add->mul->add might have problems ... x:match(W(1) + (W(2) + W(3)) * (W(4) + W(5)))</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i,j,k = x:match(W(1) + W(2) * W(3)) assertEq(i, x) assert(j == zero or k == zero) end</code>
</td><td>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.295000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>cross over add and mul ... not yet working</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>local i = (x):match(W(1) + x)	-- works</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i = (x * y):match(W(1) + x * y) assertEq(i, zero) end</code>
</td><td>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.101000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>either 1 or 2 must be zero, and either 3 or 4 must be zero</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i,j,k,l = x:match(x + W(1) * W(2) + W(3) * W(4)) assert(i == zero or j == zero) assert(k == zero or l == zero) end</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.433000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local c, f = (2 * x):match(W{1, cannotDependOn=x} * W{2, dependsOn=x}) assertEq(c, const(2)) assertEq(f, x) end</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.260000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local c, f = (2 * x):match(W{1, cannotDependOn=x} * W{2, dependsOn=x}) assertEq(c, const(2)) assertEq(f, x) end</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.179000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>Put the 'cannotDependOn' wildcard first (leftmost) in the mul for it to greedily match non-dep-on-x terms</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>otherwise 'dependsOn' will match everything, since the mul of a non-dep and a dep itself is dep on 'x', so it will include non-dep-on-terms</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local c, f = (2 * 1/x):factorDivision():match(W{index=1, cannotDependOn=x} * W{2, dependsOn=x}) assertEq(c, const(2)) assertEq(f, 1/x) end</code>
</td><td>
${2} = {2}$
<br>
${\frac{1}{x}} = {\frac{1}{x}}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 3.916000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy<br><li>/:FactorDivision:apply</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local c, f = (2 * 1/x):factorDivision():match(W{1, cannotDependOn=x} * W(2)) assertEq(c, const(2)) assertEq(f, 1/x) end</code>
</td><td>
${2} = {2}$
<br>
${\frac{1}{x}} = {\frac{1}{x}}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 2.141000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy<br><li>/:FactorDivision:apply</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({ (x + 2*y):match(W(1) + W(2) * y) }, {x,2})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.715000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({ (x + 2*y):match(W(1) * x + W(2) * y) }, {1,2})</code>
</td><td>
${2} = {2}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.688000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq( {x:match( W(1)*x + W(2))}, {1, 0})</code>
</td><td>
${2} = {2}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.613000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq( {x:match( W(1)*x + W(2)*y)}, {1, 0})</code>
</td><td>
${2} = {2}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>
${0} = {0}$
<br>
${0} = {0}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.900000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>div</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i = (1/x):match(1 / W(1)) assertEq(i, x) end</code>
</td><td>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.172000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i = (1/x):match(1 / (W(1) * x)) assertEq(i, one) end</code>
</td><td>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.154000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i = (1/x):match(1 / (W{1, cannotDependOn=x} * x)) assertEq(i, one) end</code>
</td><td>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.211000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>assert((2 * 1/x):match(2 * 1/x))</code>
</td><td>

<span style="color:green">GOOD</span>
</td><td>
time: 0.051000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i = (2 * 1/x):match(2 * 1/W(1)) assertEq(i, x) end</code>
</td><td>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.142000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i = (2 * 1/x):match(2 * 1/(W(1) * x)) assertEq(i, one) end</code>
</td><td>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.081000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local i, j = (2 * 1/x):factorDivision():match(W{1, atMost=1} * W{index=2, atMost=1}) assertEq(i, const(2)) assertEq(j, 1/x) end</code>
</td><td>
${2} = {2}$
<br>
${\frac{1}{x}} = {\frac{1}{x}}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 2.402000ms<br>
stack: size: 8<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy<br><li>/:FactorDivision:apply</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local a, b = (1/(x*(3*x+4))):match(1 / (x * (W{1, cannotDependOn=x} * x + W{2, cannotDependOn=x}))) assertEq(a, const(3)) assertEq(b, const(4)) end</code>
</td><td>
${3} = {3}$
<br>
${4} = {4}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.540000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local a, b = (1/(x*(3*x+4))):factorDivision():match(1 / (W{1, cannotDependOn=x} * x * x + W{2, cannotDependOn=x} * x)) assertEq(a, const(3)) assertEq(b, const(4)) end</code>
</td><td>
${3} = {3}$
<br>
${4} = {4}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 12.946000ms<br>
stack: size: 9<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy<br><li>*:FactorDivision:apply<br><li>*:FactorDivision:apply</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>pow</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x^2):match(x^W(1))}, {const(2)})</code>
</td><td>
${1} = {1}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.300000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x^2):match(W(1)^2)}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.357000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x^2):match(W(1)^W(2))}, {x, 2})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.372000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b>defaults:</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x):match(x^W(1))}, {const(1)})</code>
</td><td>
${1} = {1}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.273000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x):match(W(1)^1)}, {x})</code>
</td><td>
${1} = {1}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.220000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>simplifyAssertAllEq({(x):match(W(1)^W(2))}, {x, const(1)})</code>
</td><td>
${2} = {2}$
<br>
${x} = {x}$
<br>
${x} = {x}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.402000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>etc</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = sin(2*x) + cos(3*x) local a,b = expr:match( sin(W(1)) + cos(W(2)) ) print(a[1], a[2] ,b) end</code>
</td><td>
$2$	$x$	${{3}} {{x}}$

<span style="color:green">GOOD</span>
</td><td>
time: 0.154000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = sin(2*x) * cos(3*x) local a,b = expr:match( sin(W(1)) * cos(W(2)) ) print(a[1], a[2] ,b) end</code>
</td><td>
$2$	$x$	${{3}} {{x}}$

<span style="color:green">GOOD</span>
</td><td>
time: 0.433000ms<br>
stack: size: 0<br><ul style="margin:0px"></ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = (3*x^2 + 1) printbr('expr', expr) local a, c = expr:match(W{1, cannotDependOn=x} * x^2 + W{2, cannotDependOn=x}) printbr('a', a) printbr('c', c) simplifyAssertAllEq({a, c}, {3, 1}) end</code>
</td><td>
expr	${{{3}} {{{x}^{2}}}} + {1}$
<br>
a	$3$
<br>
c	$1$
<br>
${2} = {2}$
<br>
${3} = {3}$
<br>
${3} = {3}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.874000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = (3*x^2 + 2*x + 1) printbr('expr', expr) local a, b, c = expr:match(W{1, cannotDependOn=x} * x^2 + W{2, cannotDependOn=x} * x + W{3, cannotDependOn=x}) printbr('a', a) printbr('b', b) printbr('c', c) simplifyAssertAllEq({a, b, c}, {3, 2, 1}) end</code>
</td><td>
expr	${{{3}} {{{x}^{2}}}} + {{{2}} {{x}}} + {1}$
<br>
a	$3$
<br>
b	$2$
<br>
c	$1$
<br>
${3} = {3}$
<br>
${3} = {3}$
<br>
${3} = {3}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 1.720000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = (3*x^2 + 1):factorDivision() printbr('expr', expr) local a, b, c = expr:match(W{1, cannotDependOn=x} * x^2 + W{2, cannotDependOn=x} * x + W{3, cannotDependOn=x}) printbr('a', a) printbr('b', b) printbr('c', c) simplifyAssertAllEq({a, b, c}, {3, 0, 1}) end</code>
</td><td>
expr	${1} + {{{3}} {{{x}^{2}}}}$
<br>
a	false
<br>
b	nil
<br>
c	nil
<br>
${1} = {3}$
<br>
expected 1 to equal 3<br>
found $1$ vs $3$<br>
lhs stack<br>
Init	$1$	<pre>	1	</pre>
<br>
Prune	$1$	<pre>	1	</pre>
<br>
Expand	$1$	<pre>	1	</pre>
<br>
Prune	$1$	<pre>	1	</pre>
<br>
Factor	$1$	<pre>	1	</pre>
<br>
Prune	$1$	<pre>	1	</pre>
<br>
Tidy	$1$	<pre>	1	</pre>
<br>
rhs stack<br>
Init	$3$	<pre>	3	</pre>
<br>
Prune	$3$	<pre>	3	</pre>
<br>
Expand	$3$	<pre>	3	</pre>
<br>
Prune	$3$	<pre>	3	</pre>
<br>
Factor	$3$	<pre>	3	</pre>
<br>
Prune	$3$	<pre>	3	</pre>
<br>
Tidy	$3$	<pre>	3	</pre>
<br>
lhs:	1=false	<br>
rhs:	1=3, 2=0, 3=1	<br>
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/tests/unit/unit.lua:126: failed<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:182: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:175><br>
	[C]: in function 'error'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:126: in function 'simplifyAssertEq'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:169: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:168><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:168: in function 'simplifyAssertAllEq'<br>
	[string "do local expr = (3*x^2 + 1):factorDivision() ..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0	14
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: failed<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:247: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:246><br>
	[C]: in function 'error'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: in function 'simplifyAssertAllEq'<br>
	[string "do local expr = (3*x^2 + 1):factorDivision() ..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0
</td><td>
time: 4.272000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = (3*x*x + 2*x + 1):factorDivision() printbr('expr', expr) local a, b, c = expr:match(W{1, cannotDependOn=x} * x^2 + W{2, cannotDependOn=x} * x + W{3, cannotDependOn=x}) printbr('a', a) printbr('b', b) printbr('c', c) simplifyAssertAllEq({a, b, c}, {3, 2, 1}) end</code>
</td><td>
expr	${1} + {{{2}} {{x}}} + {{{3}} {{{x}^{2}}}}$
<br>
a	$3$
<br>
b	$2$
<br>
c	$1$
<br>
${3} = {3}$
<br>
${3} = {3}$
<br>
${3} = {3}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 8.187000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = (1/(3*x*x + 2*x + 1)):factorDivision() printbr('expr', expr) local a, b, c = expr:match(1 / (W{1, cannotDependOn=x} * x^2 + W{2, cannotDependOn=x} * x + W{3, cannotDependOn=x})) printbr('a', a) printbr('b', b) printbr('c', c) simplifyAssertAllEq({a, b, c}, {3, 2, 1}) end</code>
</td><td>
expr	$\frac{1}{{1} + {{{2}} {{x}}} + {{{3}} {{{x}^{2}}}}}$
<br>
a	$3$
<br>
b	$2$
<br>
c	$1$
<br>
${3} = {3}$
<br>
${3} = {3}$
<br>
${3} = {3}$
<br>
${2} = {2}$
<br>
${2} = {2}$
<br>
${1} = {1}$
<br>
${1} = {1}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 13.372000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code>do local expr = (x/(3*x*x + 2*x + 1)):factorDivision() printbr('expr', expr) local a, b, c = expr:match(1 / (W{1, cannotDependOn=x} * x^2 + W{2, cannotDependOn=x} * x + W{3, cannotDependOn=x})) printbr('a', a) printbr('b', b) printbr('c', c) simplifyAssertAllEq({a, b, c}, {3, 2, 1}) end</code>
</td><td>
expr	${{x}} {{\frac{1}{{1} + {{{2}} {{x}}} + {{{3}} {{{x}^{2}}}}}}}$
<br>
a	false
<br>
b	nil
<br>
c	nil
<br>
${1} = {3}$
<br>
expected 1 to equal 3<br>
found $1$ vs $3$<br>
lhs stack<br>
Init	$1$	<pre>	1	</pre>
<br>
Prune	$1$	<pre>	1	</pre>
<br>
Expand	$1$	<pre>	1	</pre>
<br>
Prune	$1$	<pre>	1	</pre>
<br>
Factor	$1$	<pre>	1	</pre>
<br>
Prune	$1$	<pre>	1	</pre>
<br>
Tidy	$1$	<pre>	1	</pre>
<br>
rhs stack<br>
Init	$3$	<pre>	3	</pre>
<br>
Prune	$3$	<pre>	3	</pre>
<br>
Expand	$3$	<pre>	3	</pre>
<br>
Prune	$3$	<pre>	3	</pre>
<br>
Factor	$3$	<pre>	3	</pre>
<br>
Prune	$3$	<pre>	3	</pre>
<br>
Tidy	$3$	<pre>	3	</pre>
<br>
lhs:	1=false	<br>
rhs:	1=3, 2=2, 3=1	<br>
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/tests/unit/unit.lua:126: failed<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:182: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:175><br>
	[C]: in function 'error'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:126: in function 'simplifyAssertEq'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:169: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:168><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:168: in function 'simplifyAssertAllEq'<br>
	[string "do local expr = (x/(3*x*x + 2*x + 1)):factorD..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0	14
<span style="color:red">BAD</span><br>/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: failed<br>
stack traceback:<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:247: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:246><br>
	[C]: in function 'error'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:184: in function 'simplifyAssertAllEq'<br>
	[string "do local expr = (x/(3*x*x + 2*x + 1)):factorD..."]:1: in main chunk<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:239: in function </home/chris/Projects/lua/symmath/tests/unit/unit.lua:238><br>
	[C]: in function 'xpcall'<br>
	/home/chris/Projects/lua/symmath/tests/unit/unit.lua:238: in function 'exec'<br>
	match.lua:233: in function 'cb'<br>
	/home/chris/Projects/lua/ext/timer.lua:49: in function 'timer'<br>
	match.lua:6: in main chunk<br>
	[C]: at 0x55e00041e2f0
</td><td>
time: 15.916000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b>TensorRef</b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
</td><td>
</td></tr>
<tr><td>
<b></b><br>
<code>local a = x'^i':match(Tensor.Ref(x, W(1))) simplifyAssertEq(a, Tensor.Index{symbol='i', lower=false})</code>
</td><td>
${^i} = {^i}$
<br>

<span style="color:green">GOOD</span>
</td><td>
time: 0.346000ms<br>
stack: size: 7<br><ul style="margin:0px"><li>Init<br><li>Prune<br><li>Expand<br><li>Prune<br><li>Factor<br><li>Prune<br><li>Tidy</ul>
</td></tr>
