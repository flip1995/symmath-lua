<!doctype html>
<html>
	<head>
		<meta charset='utf-8'>
		<title>func</title>
		<script type='text/javascript' src='../tryToFindMathJax.js'></script>
	</head>
	<body onload='tryToFindMathJax();'>

<table border="1" style="border-collapse:collapse">
<tr><td>
<b></b><br>
<code>x = var'x'</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>y = func('y', {x}, x^2)</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b>TODO what to display...</b><br>
<code></code>
</td><td>
<tr><td>
<b>y = x</b><br>
<code></code>
</td><td>
<tr><td>
<b>y(x) = x</b><br>
<code></code>
</td><td>
<tr><td>
<b>y(x) := x</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>print(y(x))</code>
</td><td>
$y\left(  x\right)$

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>print(y(x)())</code>
</td><td>
$y\left(  x\right)$

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>printbr(y:defeq())</code>
</td><td>
${y\left(  x\right)} = {{x}^{2}}$
<br>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>assert(UserFunction.registeredFunctions.y == y)</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>if UserFunction is not a Variable then this is invalid</b><br>
<code></code>
</td><td>
<tr><td>
<b>because you cannot have Functions as Variables in the arg list</b><br>
<code></code>
</td><td>
<tr><td>
<b>f = func('f', {x, y}, x*y)</b><br>
<code></code>
</td><td>
<tr><td>
<b>print(f:defeq())</b><br>
<code></code>
</td><td>
<tr><td>
<b>assert(UserFunction.registeredFunctions.f == f)</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>instead, if UserFunction returns Functions, this is what you would see</b><br>
<code></code>
</td><td>
<tr><td>
<b>and with this the derivative evaluation is obvious</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>f = func('f', {x}, x*y(x))</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>print(f:defeq())</code>
</td><td>
${f\left(  x\right)} = {{{x}} {{y\left(  x\right)}}}$

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>assert(UserFunction.registeredFunctions.f == f)</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>diff() is total derivative</b><br>
<code></code>
</td><td>
<tr><td>
<b>pdiff() is partial derivative</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>total derivative evaluation</b><br>
<code></code>
</td><td>
<tr><td>
<b>substitute chain rule for all terms</b><br>
<code></code>
</td><td>
<tr><td>
<b>df/dx, when simplified, does not go anywhere, because f is dependent on x</b><br>
<code></code>
</td><td>
<tr><td>
<b>for that reason, I can just build the equality f:eq(f.def) and apply :diff() to the whole thing:</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>print(f:defeq():diff(x):prune())</code>
</td><td>
${f'\left(  x\right)} = {{y\left(  x\right)} + {{{x}} {{y'\left(  x\right)}}}}$

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>print(f:defeq():diff(y):prune())</code>
</td><td>
<span style="color:red">BAD</span><br>C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: attempt to call a table value<br>stack traceback:<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:93: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:92><br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:35: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\visitor\Visitor.lua:66: in function 'prune'<br>
	[string "print(f:defeq():diff(y):prune())"]:1: in main chunk<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:85: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84: in function 'exec'<br>
	unit\func.lua:56: in main chunk<br>
	[C]: at 0x7ff780b24950
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>s = var's'</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>t = var't'</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>x = func('x', {s,t})</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>y = func('y', {s,t})</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>f = func('f', {x,y})</code>
</td><td>
<span style="color:red">BAD</span><br>C:\Users\Chris\Projects\lua\symmath\UserFunction.lua:180: args must be a table of Variables<br>stack traceback:<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:93: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:92><br>
	[C]: in function 'assert'<br>
	C:\Users\Chris\Projects\lua\symmath\UserFunction.lua:180: in function 'func'<br>
	[string "f = func('f', {x,y})"]:1: in main chunk<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:85: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84: in function 'exec'<br>
	unit\func.lua:56: in main chunk<br>
	[C]: at 0x7ff780b24950
</td></tr>
<tr><td>
<b>∂f/∂x</b><br>
<code>print(f:diff(x):prune())</code>
</td><td>
<span style="color:red">BAD</span><br>C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: attempt to call a table value<br>stack traceback:<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:93: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:92><br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:35: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\visitor\Visitor.lua:66: in function 'prune'<br>
	[string "print(f:diff(x):prune())"]:1: in main chunk<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:85: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84: in function 'exec'<br>
	unit\func.lua:56: in main chunk<br>
	[C]: at 0x7ff780b24950
</td></tr>
<tr><td>
<b>∂f/∂y</b><br>
<code>print(f:diff(y):prune())</code>
</td><td>
<span style="color:red">BAD</span><br>C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: attempt to call a table value<br>stack traceback:<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:93: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:92><br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:35: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\visitor\Visitor.lua:66: in function 'prune'<br>
	[string "print(f:diff(y):prune())"]:1: in main chunk<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:85: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84: in function 'exec'<br>
	unit\func.lua:56: in main chunk<br>
	[C]: at 0x7ff780b24950
</td></tr>
<tr><td>
<b>∂f/∂x ∂x/∂s + ∂f/∂y ∂y/∂s</b><br>
<code>print(f:diff(s):prune())</code>
</td><td>
<span style="color:red">BAD</span><br>C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: attempt to call a table value<br>stack traceback:<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:93: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:92><br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:35: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\visitor\Visitor.lua:66: in function 'prune'<br>
	[string "print(f:diff(s):prune())"]:1: in main chunk<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:85: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84: in function 'exec'<br>
	unit\func.lua:56: in main chunk<br>
	[C]: at 0x7ff780b24950
</td></tr>
<tr><td>
<b>∂f/∂x ∂x/∂t + ∂f/∂y ∂y/∂t</b><br>
<code>print(f:diff(t):prune())</code>
</td><td>
<span style="color:red">BAD</span><br>C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: attempt to call a table value<br>stack traceback:<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:93: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:92><br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:37: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\Expression.lua:35: in function 'clone'<br>
	C:\Users\Chris\Projects\lua\symmath\visitor\Visitor.lua:66: in function 'prune'<br>
	[string "print(f:diff(t):prune())"]:1: in main chunk<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:85: in function <C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	C:\Users\Chris\Projects\lua\symmath\tests\unit\unit.lua:84: in function 'exec'<br>
	unit\func.lua:56: in main chunk<br>
	[C]: at 0x7ff780b24950
</td></tr>
<tr><td>
<b>TODO I need something to represent ∂/∂x "the def of f", rather than ∂/∂x "f", which is zero.</b><br>
<code></code>
</td><td>
<tr><td>
<b>in contrast ∂/∂x "the def of f" would be a placeholder (in absense of f's provided definition)</b><br>
<code></code>
</td><td>
