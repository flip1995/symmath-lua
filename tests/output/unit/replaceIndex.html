<!doctype html>
<html>
    <head>
        <meta charset='utf-8'>
        <title>replaceIndex</title>
		<script type='text/javascript' src='../tryToFindMathJax.js'></script>
    </head>
	<body onload='tryToFindMathJax();'>

<table border="1" style="border-collapse:collapse">
<tr><td>
<b>variance must match in order for the replace to work</b><br>
<code>asserteq( a'_a':replaceIndex(a'^u', b'^u'), a'_a')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^b'), b'^a' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^b' + c'^b'), b'^a' + c'^a' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b>the sum indexes won't use the same symbol, because the symbols are not preserved and instead chosen among unused symbols in the result expression</b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^bc' * c'_c'), b'^ab' * c'_b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^b' + c'^bc' * d'_c'), b'^a' + c'^ab' * d'_b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>TODO looks like indexes get reversed</b><br>
<code>asserteq( a'_ab':replaceIndex(a'_uv', b'_uv'), b'_ab')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'_ab':replaceIndex(a'_uv', b'_vu'), b'_ba')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( (a'_a' + b'_ab' * c'^b'):replaceIndex(a'_u', b'_u'), b'_a' + b'_ab' * c'^b')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>TODO this should preserve the order of b_ab -> c_ab</b><br>
<code>asserteq( (a'_a' + b'_ab' * c'^b'):replaceIndex(b'_uv', c'_uv'), a'_a' + c'_ab' * c'^b')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>TODO this should preserve the order of b_ab -> d_ab</b><br>
<code>asserteq( (a'_a' + b'_ab' * c'^b'):replaceIndex(b'_uv', d'_uv'), a'_a' + d'_ab' * c'^b')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>what should this produce?  Technically it is invalid match, only matching one index.  All indexes should match for a replacement to be made.  Technically this maybe should be an error?</b><br>
<code>asserteq( (a'_a' + b'_ab' * c'^b'):replaceIndex(b'_uv', c'_bv'), a'_a' + c'_ab' * c'^b')</code>
</td><td>
expected ${{ a}_a} + {{{{{ c}_b}_b}} {{{ c}^b}}}$ to equal ${{ a}_a} + {{{{{ c}_a}_b}} {{{ c}^b}}}$<br>
instead found ${{ a}_a} + {{{{ c}^b}} {{{{ c}_b}_b}}}$ vs ${{ a}_a} + {{{{ c}^b}} {{{{ c}_a}_b}}}$<br>
lhs stack<br>
init	${{ a}_a} + {{{{{ c}_b}_b}} {{{ c}^b}}}$	<br>
prune	${{ a}_a} + {{{{ c}^b}} {{{{ c}_b}_b}}}$	<br>
expand	${{ a}_a} + {{{{ c}^b}} {{{{ c}_b}_b}}}$	<br>
prune	${{ a}_a} + {{{{ c}^b}} {{{{ c}_b}_b}}}$	<br>
factor	${{ a}_a} + {{{{ c}^b}} {{{{ c}_b}_b}}}$	<br>
prune	${{ a}_a} + {{{{ c}^b}} {{{{ c}_b}_b}}}$	<br>
rhs stack<br>
init	${{ a}_a} + {{{{{ c}_a}_b}} {{{ c}^b}}}$	<br>
prune	${{ a}_a} + {{{{ c}^b}} {{{{ c}_a}_b}}}$	<br>
expand	${{ a}_a} + {{{{ c}^b}} {{{{ c}_a}_b}}}$	<br>
prune	${{ a}_a} + {{{{ c}^b}} {{{{ c}_a}_b}}}$	<br>
factor	${{ a}_a} + {{{{ c}^b}} {{{{ c}_a}_b}}}$	<br>
prune	${{ a}_a} + {{{{ c}^b}} {{{{ c}_a}_b}}}$	<br>
<span style="color:red">BAD</span><br>./unit.lua:28: failed<br>stack traceback:<br>
	./unit.lua:92: in function <./unit.lua:91><br>
	[C]: in function 'error'<br>
	./unit.lua:28: in function 'asserteq'<br>
	[string "asserteq( (a'_a' + b'_ab' * c'^b'):replaceInd..."]:1: in main chunk<br>
	./unit.lua:84: in function <./unit.lua:83><br>
	[C]: in function 'xpcall'<br>
	./unit.lua:83: in function 'exec'<br>
	./replaceIndex.lua:34: in main chunk<br>
	[C]: at 0x5628a524f1c0
</td></tr>
