<!doctype html>
<html>
    <head>
        <meta charset='utf-8'>
        <title>replaceIndex</title>
		<script type='text/javascript' src='../tryToFindMathJax.js'></script>
    </head>
	<body onload='tryToFindMathJax();'>

<table border="1" style="border-collapse:collapse">
<tr><td>
<b></b><br>
<code>asserteq( a:replaceIndex(a, b), b )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>variance must match in order for the replace to work</b><br>
<code>asserteq( a'_a':replaceIndex(a'^u', b'^u'), a'_a' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^b'), b'^a' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^b' + c'^b'), b'^a' + c'^a' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b>the sum indexes won't use the same symbol, because the symbols are not preserved and instead chosen among unused symbols in the result expression</b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^bc' * c'_c'), b'^ab' * c'_b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a':replaceIndex(a'^b', b'^b' + c'^bc' * d'_c'), b'^a' + c'^ab' * d'_b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>TODO looks like indexes get reversed</b><br>
<code>asserteq( a'_ab':replaceIndex(a'_uv', b'_uv'), b'_ab' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'_ab':replaceIndex(a'_uv', b'_vu'), b'_ba' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'_ba':replaceIndex(a'_uv', b'_vu'), b'_ab' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'_ab':replaceIndex(a'_vu', b'_uv'), b'_ba' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'_ba':replaceIndex(a'_vu', b'_uv'), b'_ab' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( (g'^am' * c'_mbc'):replaceIndex( g'^am' * c'_mbc', c'^a_bc' ), c'^a_bc')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( (g'^ad' * c'_dbc'):replaceIndex( g'^im' * c'_mjk', c'^i_jk' ), c'^a_bc')</code>
</td><td>
expected ${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$ to equal ${{{ c}^a}_b}_c$<br>
instead found ${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$ vs ${{{ c}^a}_b}_c$<br>
lhs stack<br>
init	${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$	<br>
prune	${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$	<br>
expand	${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$	<br>
prune	${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$	<br>
factor	${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$	<br>
prune	${{{{ g}^a}^d}} {{{{{ c}_d}_b}_c}}$	<br>
rhs stack<br>
init	${{{ c}^a}_b}_c$	<br>
prune	${{{ c}^a}_b}_c$	<br>
expand	${{{ c}^a}_b}_c$	<br>
prune	${{{ c}^a}_b}_c$	<br>
factor	${{{ c}^a}_b}_c$	<br>
prune	${{{ c}^a}_b}_c$	<br>
<span style="color:red">BAD</span><br>./unit.lua:28: failed<br>stack traceback:<br>
	./unit.lua:93: in function <./unit.lua:92><br>
	[C]: in function 'error'<br>
	./unit.lua:28: in function 'asserteq'<br>
	[string "asserteq( (g'^ad' * c'_dbc'):replaceIndex( g'..."]:1: in main chunk<br>
	./unit.lua:85: in function <./unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	./unit.lua:84: in function 'exec'<br>
	./replaceIndex.lua:91: in main chunk<br>
	[C]: at 0x5597582361c0
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( (a'_a' + b'_ab' * c'^b'):replaceIndex(a'_u', b'_u'), b'_a' + b'_ab' * c'^b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>TODO this should preserve the order of b_ab -> c_ab</b><br>
<code>asserteq( (a'_a' + b'_ab' * c'^b'):replaceIndex(b'_uv', c'_uv'), a'_a' + c'_ab' * c'^b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>TODO this should preserve the order of b_ab -> d_ab</b><br>
<code>asserteq( (a'_a' + b'_ab' * c'^b'):replaceIndex(b'_uv', d'_uv'), a'_a' + d'_ab' * c'^b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( a'^a_a':replaceIndex(a'^a_a', b'^a_a'), b'^a_a')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a_a':replaceIndex(a'^u_u', b'^u_u'), b'^a_a')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( (a'^a_a' * a'^b_b'):replaceIndex(a'^u_u', b'^u_u'), b'^a_a' * b'^b_b')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( a'^a_ab':replaceIndex(a'^a_ab', b'_b'), b'_b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'^a_ab':replaceIndex(a'^a_ab', b'_b' + c'_a^a_b'), b'_b' + c'_a^a_b' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>hmm, how to account for this?  if the fixed indexes don't match then I still want it to fall back on a plain replace()</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( a'_t':replaceIndex(a'_t', b), b)</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( a'_t':replaceIndex(a'_t', b'_u'), b'_u')</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b>but in the event of a regular replace, I still want it to not collide sum indexes</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( (a'_t' * b'^a_a'):replaceIndex(a'_t', c'_u' * d'^a_a'), c'_u' * b'^a_a' * d'^b_b')</code>
</td><td>
expected ${{{{{ c}_u}} {{{{ d}^a}_a}}}} {{{{ b}^a}_a}}$ to equal ${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$<br>
instead found ${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^a}_a}}$ vs ${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$<br>
lhs stack<br>
init	${{{{{ c}_u}} {{{{ d}^a}_a}}}} {{{{ b}^a}_a}}$	<br>
prune	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^a}_a}}$	<br>
expand	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^a}_a}}$	<br>
prune	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^a}_a}}$	<br>
factor	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^a}_a}}$	<br>
prune	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^a}_a}}$	<br>
rhs stack<br>
init	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$	<br>
prune	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$	<br>
expand	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$	<br>
prune	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$	<br>
factor	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$	<br>
prune	${{{ c}_u}} {{{{ b}^a}_a}} {{{{ d}^b}_b}}$	<br>
<span style="color:red">BAD</span><br>./unit.lua:28: failed<br>stack traceback:<br>
	./unit.lua:93: in function <./unit.lua:92><br>
	[C]: in function 'error'<br>
	./unit.lua:28: in function 'asserteq'<br>
	[string "asserteq( (a'_t' * b'^a_a'):replaceIndex(a'_t..."]:1: in main chunk<br>
	./unit.lua:85: in function <./unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	./unit.lua:84: in function 'exec'<br>
	./replaceIndex.lua:91: in main chunk<br>
	[C]: at 0x5597582361c0
</td></tr>
<tr><td>
<b>what does this mean? the fixed indexes shouldn't have to match ...</b><br>
<code></code>
</td><td>
<tr><td>
<b>if they don't match then assume they are not correlated between the 'find' and 'replace'</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( (a'_ij' + c'_,t' * b'_ij'):replaceIndex( c'_,t', c * d'^i_i' ), a'_ij' + c * d'^a_a' * b'_ij' )</code>
</td><td>
expected ${{{ a}_i}_j} + {{{{{c}} {{{{ d}^i}_i}}}} {{{{ b}_i}_j}}}$ to equal ${{{ a}_i}_j} + {{{c}} {{{{ d}^a}_a}} {{{{ b}_i}_j}}}$<br>
instead found ${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^i}_i}}}$ vs ${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^a}_a}}}$<br>
lhs stack<br>
init	${{{ a}_i}_j} + {{{{{c}} {{{{ d}^i}_i}}}} {{{{ b}_i}_j}}}$	<br>
prune	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^i}_i}}}$	<br>
expand	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^i}_i}}}$	<br>
prune	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^i}_i}}}$	<br>
factor	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^i}_i}}}$	<br>
prune	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^i}_i}}}$	<br>
rhs stack<br>
init	${{{ a}_i}_j} + {{{c}} {{{{ d}^a}_a}} {{{{ b}_i}_j}}}$	<br>
prune	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^a}_a}}}$	<br>
expand	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^a}_a}}}$	<br>
prune	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^a}_a}}}$	<br>
factor	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^a}_a}}}$	<br>
prune	${{{ a}_i}_j} + {{{c}} {{{{ b}_i}_j}} {{{{ d}^a}_a}}}$	<br>
<span style="color:red">BAD</span><br>./unit.lua:28: failed<br>stack traceback:<br>
	./unit.lua:93: in function <./unit.lua:92><br>
	[C]: in function 'error'<br>
	./unit.lua:28: in function 'asserteq'<br>
	[string "asserteq( (a'_ij' + c'_,t' * b'_ij'):replaceI..."]:1: in main chunk<br>
	./unit.lua:85: in function <./unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	./unit.lua:84: in function 'exec'<br>
	./replaceIndex.lua:91: in main chunk<br>
	[C]: at 0x5597582361c0
</td></tr>
<tr><td>
<b></b><br>
<code>asserteq( (a'_ab' + c'_,t' * b'_ab'):replaceIndex( c'_,t', c * d'^a_a' ), a'_ab' + c * d'^c_c' * b'_ab' )</code>
</td><td>
expected ${{{ a}_a}_b} + {{{{{c}} {{{{ d}^a}_a}}}} {{{{ b}_a}_b}}}$ to equal ${{{ a}_a}_b} + {{{c}} {{{{ d}^c}_c}} {{{{ b}_a}_b}}}$<br>
instead found ${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^a}_a}}}$ vs ${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^c}_c}}}$<br>
lhs stack<br>
init	${{{ a}_a}_b} + {{{{{c}} {{{{ d}^a}_a}}}} {{{{ b}_a}_b}}}$	<br>
prune	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^a}_a}}}$	<br>
expand	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^a}_a}}}$	<br>
prune	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^a}_a}}}$	<br>
factor	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^a}_a}}}$	<br>
prune	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^a}_a}}}$	<br>
rhs stack<br>
init	${{{ a}_a}_b} + {{{c}} {{{{ d}^c}_c}} {{{{ b}_a}_b}}}$	<br>
prune	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^c}_c}}}$	<br>
expand	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^c}_c}}}$	<br>
prune	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^c}_c}}}$	<br>
factor	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^c}_c}}}$	<br>
prune	${{{ a}_a}_b} + {{{c}} {{{{ b}_a}_b}} {{{{ d}^c}_c}}}$	<br>
<span style="color:red">BAD</span><br>./unit.lua:28: failed<br>stack traceback:<br>
	./unit.lua:93: in function <./unit.lua:92><br>
	[C]: in function 'error'<br>
	./unit.lua:28: in function 'asserteq'<br>
	[string "asserteq( (a'_ab' + c'_,t' * b'_ab'):replaceI..."]:1: in main chunk<br>
	./unit.lua:85: in function <./unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	./unit.lua:84: in function 'exec'<br>
	./replaceIndex.lua:91: in main chunk<br>
	[C]: at 0x5597582361c0
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>TODO so it looks like, when the replace expression has sum terms *AND* it is an Expression instead of just a TensorRef</b><br>
<code></code>
</td><td>
<tr><td>
<b>that's when the sum indexes aren't replaced correctly</b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>asserteq( (a'_ij' + c'_,t' * b'_ij'):replaceIndex( c'_,t', c * d'^i_i' + e'^i_i' ), a'_ij' + (c * d'^a_a' + e'^a_a') * b'_ij' )</code>
</td><td>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b></b><br>
<code>printbr( g'_ij,t':eq(d * (d * b'^k_,i' * g'_kj' + d * b'^k_,j' * g'_ki' + d * b'^k' * c'_ijk' + d * b'^k' * c'_jik' + 2 * d'_,t' * g'_ij' - 2 * d * a * e'_ij') ):replaceIndex( d'_,t',  frac(1,3) * (3 * d'_,i' * b'^i' - d * b'^i_,i' - frac(1,2) * d * b'^i' * g'_,i' / g + e * d * a) ) )</code>
</td><td>
${{{{ g}_i}_j}_{,t}} = {{{d}} {{({{{{{d}} {{{{ b}^k}_{,i}}} {{{{ g}_k}_j}}} + {{{d}} {{{{ b}^k}_{,j}}} {{{{ g}_k}_i}}} + {{{d}} {{{ b}^k}} {{{{{ c}_i}_j}_k}}} + {{{d}} {{{ b}^k}} {{{{{ c}_j}_i}_k}}} + {{{2}} {{{{\frac{1}{3}}} {{({{{{{{3}} {{{ d}_{,a}}} {{{ b}^a}}} - {{{d}} {{{{ b}^a}_{,a}}}}} - {{\frac{1}{g}}{({{{\frac{1}{2}}} {{d}} {{{ b}^a}} {{{ g}_{,a}}}})}}} + {{{e}} {{d}} {{a}}}})}}}} {{{{ g}_i}_j}}}} - {{{2}} {{d}} {{a}} {{{{ e}_i}_j}}}})}}}$
<br>

<span style="color:green">GOOD</span>
</td></tr>
<tr><td>
<b></b><br>
<code></code>
</td><td>
<tr><td>
<b>and what about when find/replace has a partial number of fixed indexes</b><br>
<code></code>
</td><td>
<tr><td>
<b>what should this produce?  Technically it is invalid match, since the from and to don't have matching fixed indexes.  So... assert error?</b><br>
<code>asserterror(function() (a'_a' + b'_ab' * c'^b'):replaceIndex(b'_uv', c'_bv') end )</code>
</td><td>
<span style="color:red">BAD</span><br>./unit.lua:35: expected an error, but found none<br>stack traceback:<br>
	./unit.lua:93: in function <./unit.lua:92><br>
	[C]: in function 'assert'<br>
	./unit.lua:35: in function 'asserterror'<br>
	[string "asserterror(function() (a'_a' + b'_ab' * c'^b..."]:1: in main chunk<br>
	./unit.lua:85: in function <./unit.lua:84><br>
	[C]: in function 'xpcall'<br>
	./unit.lua:84: in function 'exec'<br>
	./replaceIndex.lua:91: in main chunk<br>
	[C]: at 0x5597582361c0
</td></tr>
