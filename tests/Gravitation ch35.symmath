{
	{hidden=false, input="t,x,y,z = vars('t','x','y','z')", output="$t$\9$x$\9$y$\9$z$", outputtype="html", uid=73},
	{hidden=false, input="chart = Tensor.Chart{coords={t,x,y,z}}", output="table: 0x5632c42dbfb0", outputtype="html", uid=28},
	{hidden=false, input="dim = #chart.coords", output="4", outputtype="html", uid=52},
	{hidden=false, input="-- TODO technically for weak-field linearized, g_ab = eta_ab + h_ab is the metric, though indexes are raised/lowered using eta_ab and not g_ab \netaLLval = Tensor('_ab', Matrix.diagonal(-1,1,1,1):unpack())\nchart:setMetric(etaLLval)\nprint(eta'_ab':eq(etaLLval));", output="${{{ \\eta} _a} _b} = {\\overset{a\\downarrow b\\rightarrow}{\\left[ \\begin{matrix}  -1 &  0 &  0 &  0 \\\\  0 &  1 &  0 &  0 \\\\  0 &  0 &  1 &  0 \\\\  0 &  0 &  0 &  1\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=30},
	{hidden=false, input="etaUUval = chart.metricInverse\nprint(eta'^ab':eq(etaUUval));", output="${{{ \\eta} ^a} ^b} = {\\overset{a\\downarrow b\\rightarrow}{\\left[ \\begin{matrix}  -{1} &  0 &  0 &  0 \\\\  0 &  1 &  0 &  0 \\\\  0 &  0 &  1 &  0 \\\\  0 &  0 &  0 &  1\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=31},
	{hidden=false, input="-- ...and therefore, since eta_ab raises/lowers indexes, \n-- (technically eta^ab raises and g_ab lowered, and (h_ab)^2 ~ 0, \n-- therefore raising and lowering will produce a (h_ab)^2 term which is then approximated to zero)\n-- lets use eta for our Tensor.metricVariable\nTensor.metricVariable = eta", output="$\\eta$", outputtype="html", uid=49},
	{hidden=false, input="-- section 2", output="", outputtype="html", uid=12},
	{hidden=false, input="gdef = g'_uv':eq(eta'_uv' + h'_uv')", output="${{{ g} _u} _v} = {{{{ \\eta} _u} _v} + {{{ h} _u} _v}}$", outputtype="html", uid=1},
	{hidden=false, input="hbar = var'\\\\bar{h}'", output="$\\bar{h}$", outputtype="html", uid=2},
	{hidden=false, input="hbardef = hbar'_uv':eq(h'_uv' - frac(1,2) * eta'_uv' * h'^a_a')", output="${{{ \\bar{h}} _u} _v} = {{{{ h} _u} _v} + {-{{{\\frac{1}{2}}} {{{{ \\eta} _u} _v}} {{{{ h} ^a} _a}}}}}$", outputtype="html", uid=3},
	{hidden=false, input="trhbardef = (hbardef * eta'^uv')\n\9:simplifyMetrics()\n\9:tidyIndexes()()", output="${{{ \\bar{h}} ^a} _a} = {-{{{ h} ^a} _a}}$", outputtype="html", uid=50},
	{hidden=false, input="-- this isn't in ch.35, but is in earlier chapters on weak-field de-Donder linearized GR, and the results are referenced (iirc)\nhbargauge = hbar'_uv^,v':eq(0)", output="${{{{ \\bar{h}} _u} _v} ^{,v}} = {0}$", outputtype="html", uid=44},
	{hidden=false, input="-- TODO make use of simplifyMetrics(), and make simplifyMetrics() work with comma variables *ONLY* when the metric itself is defined *AND* constant\n-- *OR* allow a rule to be set somehow that \"metricIsConstant\" or something, in the case that dense tensors aren't being used.\nhgauge = hbargauge:splitOffDerivIndexes()\n\9:subst(hbardef, trhbardef)\n\9:replace(h'^a_a', h'_ab' * eta'^ab')\n\9:simplifyAddMulDiv()\n\9:replace(eta'^ab,v', 0)\n\9:replace(eta'_uv^,v', 0)\n\9:simplify()\n\9:replace(eta'^ab' * eta'_uv' * h'_ab^,v', h'^v_v,u')\n\9:solve(h'_uv^,v')()", output="${{{{ h} _u} _v} ^{,v}} = {{\\frac{1}{2}} {{{{ h} ^v} _v} _{,u}}}$", outputtype="html", uid=45},
	{hidden=false, input="connLdef = Gamma'_abc':eq(frac(1,2)*(g'_ab,c' + g'_ac,b' - g'_bc,a'))", output="${{{{ \\Gamma} _a} _b} _c} = {{{\\frac{1}{2}}} {{\\left({{{{{{ g} _a} _b} _{,c}} + {{{{ g} _a} _c} _{,b}}} + {-{{{{ g} _b} _c} _{,a}}}}\\right)}}}$", outputtype="html", uid=46},
	{hidden=false, input="connLdef = connLdef:splitOffDerivIndexes():substIndex(gdef)()\n\9--:replaceIndex(eta'_ab,c', 0)\9-- why does this only replace eta_ab,c and ignore all others?\n\9:replace(eta'_ab,c', 0):replace(eta'_ac,b', 0):replace(eta'_bc,a', 0)\n\9:simplify()", output="${{{{ \\Gamma} _a} _b} _c} = {{\\frac{1}{2}}{\\left({{{{{ h} _a} _c} _{,b}} + {{{{{ h} _a} _b} _{,c}} + {-{{{{ h} _b} _c} _{,a}}}}}\\right)}}$", outputtype="html", uid=47},
	{hidden=false, input="conndef = (connLdef:reindex{a='u'}*eta'^au')()\n\9:simplifyMetrics()\n\9:simplify()\n\9-- TODO set up the rules to raise/lower commas in the case that eta is constant", output="${{{{ \\Gamma} ^a} _b} _c} = {{\\frac{1}{2}} {{{{{ \\eta} ^a} ^u}} {{\\left({{{{{ h} _u} _c} _{,b}} + {{{{{ h} _u} _b} _{,c}} + {-{{{{ h} _b} _c} _{,u}}}}}\\right)}}}}$", outputtype="html", uid=48},
	{hidden=false, input="conndef = conndef:simplifyAddMulDiv()\n\9:replace(eta'^au' * h'_ub,c', h'^a_b,c')\n\9:replace(eta'^au' * h'_uc,b', h'^a_c,b')\n\9:replace(eta'^au' * h'_bc,u', h'_bc^,a')\n\9:simplify()", output="${{{{ \\Gamma} ^a} _b} _c} = {{\\frac{1}{2}}{\\left({{{{{ h} ^a} _c} _{,b}} + {{{{{ h} ^a} _b} _{,c}} + {-{{{{ h} _b} _c} ^{,a}}}}}\\right)}}$", outputtype="html", uid=53},
	{hidden=false, input="Riemanndef = R'^a_bcd':eq(Gamma'^a_bd,c' - Gamma'^a_bc,d' + Gamma'^a_ec' * Gamma'^e_bd' - Gamma'^a_ed' * Gamma'^e_bc')", output="${{{{{ R} ^a} _b} _c} _d} = {{{{{{{ \\Gamma} ^a} _b} _d} _{,c}} + {-{{{{{ \\Gamma} ^a} _b} _c} _{,d}}} + {{{{{{ \\Gamma} ^a} _e} _c}} {{{{{ \\Gamma} ^e} _b} _d}}}} + {-{{{{{{ \\Gamma} ^a} _e} _d}} {{{{{ \\Gamma} ^e} _b} _c}}}}}$", outputtype="html", uid=54},
	{hidden=false, input="Riemanndef = Riemanndef\n\9:splitOffDerivIndexes()\n\9:substIndex(conndef)\n\9:simplify()", output="${{{{{ R} ^a} _b} _c} _d} = {{\\frac{1}{4}}{\\left({{{{2}} {{{{{{ h} _b} _c} ^{,a}} _{,d}}}} + {{{2}} {{{{{{ h} ^a} _d} _{,b}} _{,c}}}} + {{{2}} {{{{{{ h} ^a} _b} _{,d}} _{,c}}}} + {{{{{{ h} ^e} _b} _{,c}}} {{{{{ h} _e} _d} ^{,a}}}} + {{{{{{ h} ^e} _c} _{,b}}} {{{{{ h} _e} _d} ^{,a}}}} + {{{{{{ h} ^a} _e} _{,c}}} {{{{{ h} ^e} _b} _{,d}}}} + {{{{{{ h} ^a} _e} _{,c}}} {{{{{ h} ^e} _d} _{,b}}}} + {{{{{{ h} ^a} _c} _{,e}}} {{{{{ h} ^e} _b} _{,d}}}} + {{{{{{ h} _b} _d} ^{,e}}} {{{{{ h} _e} _c} ^{,a}}}} + {{{{{{ h} ^a} _d} _{,e}}} {{{{{ h} _b} _c} ^{,e}}}} + {{{{{{ h} ^a} _c} _{,e}}} {{{{{ h} ^e} _d} _{,b}}}} + {{{{{{{{{{{{{{{{{{ h} ^a} _e} _{,d}}} {{{{{ h} _b} _c} ^{,e}}}} + {-{{{2}} {{{{{{ h} ^a} _c} _{,b}} _{,d}}}}}} + {-{{{2}} {{{{{{ h} _b} _d} ^{,a}} _{,c}}}}}} + {-{{{2}} {{{{{{ h} ^a} _b} _{,c}} _{,d}}}}}} + {-{{{{{{ h} ^a} _d} _{,e}}} {{{{{ h} ^e} _b} _{,c}}}}}} + {-{{{{{{ h} ^a} _e} _{,d}}} {{{{{ h} ^e} _b} _{,c}}}}}} + {-{{{{{{ h} ^e} _d} _{,b}}} {{{{{ h} _e} _c} ^{,a}}}}}} + {-{{{{{{ h} ^a} _e} _{,c}}} {{{{{ h} _b} _d} ^{,e}}}}}} + {-{{{{{{ h} ^a} _e} _{,d}}} {{{{{ h} ^e} _c} _{,b}}}}}} + {-{{{{{{ h} ^e} _b} _{,d}}} {{{{{ h} _e} _c} ^{,a}}}}}} + {-{{{{{{ h} ^a} _c} _{,e}}} {{{{{ h} _b} _d} ^{,e}}}}}} + {-{{{{{{ h} _b} _c} ^{,e}}} {{{{{ h} _e} _d} ^{,a}}}}}} + {-{{{{{{ h} ^a} _d} _{,e}}} {{{{{ h} ^e} _c} _{,b}}}}}}}\\right)}}$", outputtype="html", uid=56},
	{hidden=false, input="-- hmm ... Riemanndef:replaceIndex(h'_ab,^c' * h'_ef,^g', 0) doesn't work...\n-- probably because there are sum terms that it isn't matching to ...\n-- can I include all of them here?\n--[[\nRiemanndef:replaceIndex(h'^e_b,c' * h'_ed^,a', 0)\n--]]\n-- probably not, since :replaceIndex() of this exact expression still won't match it ...\n-- so the other alternative is to write out every explicit (∂h_ij)^2 term in replace() functions ...\n-- and there should be 18 of those from (Γ^i_jk)^2 , minus any matches terms ...\n-- almost as much typing as the map() and matching to (∂h_ij)^2 ...\n--[[\nRiemanndef\n\9:replace(h'^e_b,c' * h'_ed^,a', 0)\n\9:replace(h'^a_e,c' * h'^e_b,d', 0)\n\9:replace(h'^e_b,c' * h'_ed^,a', 0)\n\9error(\"and more terms ...\")\n--]]\n--[[ another way is to just simplify the (Γ^i_jk)^2 itself in the replace() ... x4 to remove the wrapping constant division ...\nlocal tmp = (4 * (Gamma'^a_ec' * Gamma'^e_bd' - Gamma'^a_ed' * Gamma'^e_bc')):substIndex(conndef)():eq(0)\nprint(tmp)\nprint(Riemanndef)\nprint(Riemanndef:subst(tmp)) -- why doesn't this work?  all terms are accounted.  no wrapping div/mul.  idk.\nprint((Riemanndef - tmp:switch()/4)()) -- this works, but looks ugly\n--]]\n-- ok how about another way using match?\n-- [[\n--print(Riemanndef[2]:match(Wildcard(7) + Tensor.Ref(h, Wildcard(1), Wildcard(2), Wildcard(3)) * Tensor.Ref(h, Wildcard(4), Wildcard(5), Wildcard(6))))\n--]]\n-- not easily.  what I need is a 'gmatch' iterator function ... or maybe iteradd() (after ignoring the 1/4 factor on the outside), and then match() and replace ...", output="", outputtype="html", uid=74},
	{hidden=false, input="-- hmm ... Riemanndef:replaceIndex(h'_ab,^c' * h'_ef,^g', 0) doesn't work...\nlocal function isdh(x)\n\9return Tensor.Ref:isa(x)\n\9and #x == 4\n\9and x[1] == h\n\9and x[4].derivative\nend \nRiemanndef = Riemanndef:map(function(x)\n\9if symmath.op.mul:isa(x) and #x == 2\n\9and isdh(x[1]) and isdh(x[2])\n\9then\n\9\9return 0\n\9end\nend)()\nprint(Riemanndef);", output="${{{{{ R} ^a} _b} _c} _d} = {{\\frac{1}{2}}{\\left({{{{{{ h} _b} _c} ^{,a}} _{,d}} + {{{{{ h} ^a} _d} _{,b}} _{,c}} + {{{{{{{{ h} ^a} _b} _{,d}} _{,c}} + {-{{{{{ h} ^a} _c} _{,b}} _{,d}}}} + {-{{{{{ h} _b} _d} ^{,a}} _{,c}}}} + {-{{{{{ h} ^a} _b} _{,c}} _{,d}}}}}\\right)}}$<br>\n", outputtype="html", uid=55},
	{hidden=false, input="Riemanndef = Riemanndef\n\9:symmetrizeIndexes(h, {1,2}, true)\n\9:symmetrizeIndexes(h, {3,4}, true)\n\9:simplify()", output="${{{{{ R} ^a} _b} _c} _d} = {{\\frac{1}{2}}{\\left({{{{{{ h} _b} _c} ^{,a}} _{,d}} + {{{{{{{ h} ^a} _d} _{,b}} _{,c}} + {-{{{{{ h} ^a} _c} _{,b}} _{,d}}}} + {-{{{{{ h} _b} _d} ^{,a}} _{,c}}}}}\\right)}}$", outputtype="html", uid=60},
	{hidden=false, input="Riccidef = Riemanndef:reindex{abcd='uaub'}:replace(R'^u_aub', R'_ab')", output="${{{ R} _a} _b} = {{\\frac{1}{2}}{\\left({{{{{{ h} _a} _u} ^{,u}} _{,b}} + {{{{{{{ h} ^u} _b} _{,a}} _{,u}} + {-{{{{{ h} ^u} _u} _{,a}} _{,b}}}} + {-{{{{{ h} _a} _b} ^{,u}} _{,u}}}}}\\right)}}$", outputtype="html", uid=57},
	{hidden=false, input="print(hgauge:reindex{uv='au'}'_,b'())\nprint(hgauge:reindex{uv='bu'}'_,a'())\nRiccidef = Riccidef\n\9:subst(hgauge:reindex{uv='au'}'_,b'())\n\9:replace(h'^u_b,au', h'_bu,^u_a')\n\9:subst(hgauge:reindex{uv='bu'}'_,a'())\n\9:replace(h'^u_u,ba', h'^u_u,ab')\n\9:simplify()\nprint(Riccidef);", output="${{{{{ h} _a} _u} ^{,u}} _{,b}} = {{\\frac{1}{2}} {{{{{ h} ^u} _u} _{,a}} _{,b}}}$<br>\n${{{{{ h} _b} _u} ^{,u}} _{,a}} = {{\\frac{1}{2}} {{{{{ h} ^u} _u} _{,b}} _{,a}}}$<br>\n${{{ R} _a} _b} = {-{{\\frac{1}{2}} {{{{{ h} _a} _b} ^{,u}} _{,u}}}}$<br>\n", outputtype="html", uid=59},
	{hidden=false, input="EinsteinDef = G'_ab':eq(R'_ab' - frac(1,2) * eta'_ab' * R'_uv' * eta'^uv')", output="${{{ G} _a} _b} = {{{{ R} _a} _b} + {-{{{\\frac{1}{2}}} {{{{ \\eta} _a} _b}} {{{{ R} _u} _v}} {{{{ \\eta} ^u} ^v}}}}}$", outputtype="html", uid=61},
	{hidden=false, input="-- there has to be an easier way to apply this rule...\nlocal trhdef = h'^u_u':eq(h'_uv' * eta'^uv')\nlocal repl = hbardef:reindex{auv='uab'}',^c_c'\n\9:subst(trhdef, trhdef',^c_c'())\n\9:simplifyAddMulDiv()\n\9:replace(eta'^uv,c_c', 0)\n\9:replace(eta'_ab^,c_c', 0)\n\9:simplifyAddMulDiv()\nrepl = (repl * -2):simplifyAddMulDiv()\nprint(repl)\nEinsteinDef = EinsteinDef:substIndex(Riccidef)()\nEinsteinDef[2] = EinsteinDef[2] - repl[2]/4 + repl[1]/4\nEinsteinDef = EinsteinDef()\nprint(EinsteinDef)", output="${{{-2}} {{{{{{ \\bar{h}} _a} _b} ^{,c}} _{,c}}}} = {{{{-2}} {{{{{{ h} _a} _b} ^{,c}} _{,c}}}} + {{{{{ \\eta} _a} _b}} {{{{ \\eta} ^u} ^v}} {{{{{{ h} _u} _v} ^{,c}} _{,c}}}}}$<br>\n${{{ G} _a} _b} = {-{{\\frac{1}{2}} {{{{{ \\bar{h}} _a} _b} ^{,c}} _{,c}}}}$<br>\n", outputtype="html", uid=62},
	{hidden=false, input="EFEdef = G'_ab':eq(8 * pi * T'_ab')", output="${{{ G} _a} _b} = {{{8}} {{π}} \\cdot {{{{ T} _a} _b}}}$", outputtype="html", uid=63},
	{hidden=false, input="-- wave equation:\nEFEdef = EFEdef:subst(EinsteinDef):solve(hbar'_ab,^c_c')", output="${{{{{ \\bar{h}} _a} _b} ^{,c}} _{,c}} = {-{{{16}} {{π}} \\cdot {{{{ T} _a} _b}}}}$", outputtype="html", uid=65},
	{hidden=false, input="-- in vacuum\nvacuumEFEdef = EFEdef:replace(T'_ab', 0)()", output="${{{{{ \\bar{h}} _a} _b} ^{,c}} _{,c}} = {0}$", outputtype="html", uid=6},
	{hidden=false, input="-- infintesimal coordinate transformation condition\nxidef = xi'_u,a^a':eq(0)", output="${{{{ \\xi} _u} _{,a}} ^{,a}} = {0}$", outputtype="html", uid=8},
	{hidden=false, input="-- coordinate change:\nx_new'^u':eq(x_old'^u' + xi'^u')", output="${{ {x_{new}}} ^u} = {{{ {x_{old}}} ^u} + {{ \\xi} ^u}}$", outputtype="html", uid=9},
	{hidden=false, input="hbarnew = var'\\\\bar{h}_{new}'", output="${\\bar{h}_{{new}}}$", outputtype="html", uid=82},
	{hidden=false, input="hbarold = var'\\\\bar{h}_{old}'", output="${\\bar{h}_{{old}}}$", outputtype="html", uid=83},
	{hidden=false, input="-- metric gauge change:\nhgaugechangedef = hbarnew'_uv':eq(hbarold'_uv' - xi'_u,v' - xi'_v,u' + eta'_uv' * xi'^a_,a')", output="${{{ {\\bar{h}_{{new}}}} _u} _v} = {{{{{ {\\bar{h}_{{old}}}} _u} _v} + {-{{{ \\xi} _u} _{,v}}}} + {-{{{ \\xi} _v} _{,u}}} + {{{{{ \\eta} _u} _v}} {{{{ \\xi} ^a} _{,a}}}}}$", outputtype="html", uid=10},
	{hidden=false, input="-- section 3", output="", outputtype="html", uid=11},
	{hidden=false, input="-- monochromatic plane wave\nmwavedef = hbar'_uv':eq(A'_uv' * cos(k'_a' * x'^a'))", output="${{{ \\bar{h}} _u} _v} = {{{{{ A} _u} _v}} {{\\cos\\left( {{{{ k} _a}} {{{ x} ^a}}}\\right)}}}$", outputtype="html", uid=15},
	{hidden=false, input="-- honestly the above def was Re(...), but I don't have a Re() function (and my complex support is kind of bad)\n-- so here's the complex version:\nmwavecplxdef = hbar'_uv':eq(A'_uv' * exp(i * k'_a' * x'^a'))", output="${{{ \\bar{h}} _u} _v} = {{{{{ A} _u} _v}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}$", outputtype="html", uid=77},
	{hidden=false, input="knulldef = (k'_a' * k'^a'):eq(0)", output="${{{{ k} _a}} {{{ k} ^a}}} = {0}$", outputtype="html", uid=16},
	{hidden=false, input="kDenseL = Tensor('_a', function(a) return k('_'..chart.coords[a].name) end)\nprint(k'_a':eq(kDenseL));", output="${{ k} _a} = {\\overset{a\\downarrow}{\\left[ \\begin{matrix} { k} _t \\\\ { k} _x \\\\ { k} _y \\\\ { k} _z\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=29},
	{hidden=false, input="kUdef = k'^a':eq(eta'^ab' * k'_b')", output="${{ k} ^a} = {{{{{ \\eta} ^a} ^b}} {{{ k} _b}}}$", outputtype="html", uid=33},
	{hidden=false, input="-- deriv k_t's def based on the index form of eta_uv ... \nprint(knulldef)\nprint(kUdef)\nlocal tmp = knulldef:subst(kUdef)\nprint(tmp)\n-- NOTICE if you change the background metric then you have to also change this ...\ntmp = (tmp[1]:reindex{ab='tt'} + tmp[1]:reindex{ab='ij'}):eq(tmp[2])\nprint(tmp)\ntmp = tmp\n\9:replace(eta'^tt', -1)\n\9:replace(eta'^ij' * k'_j', k'_i')\n\9()\nprint(tmp)\n-- solve() doesn't consider implicit sums ...\n--tmp = tmp:solve(k'_t')\n-- how about using my infamous Sum() object ... since it does nothing else at the moment ...\nlocal sumtmp = tmp:replace(k'_i'^2, Sum(k'_i'^2, i))\nprint(sumtmp)\nsumtmp = sumtmp:solve(k'_t')\n-- and viola, we have our sqrt and our sqr separate\nprint(sumtmp)\n-- but for now Sum is very rigid, so I think I'll just keep it solved for k_t^2 ... \n-- solve() isn't this clever.  i think it could if k'_t'^2 was replace()'d with a variable, and then the Variable was solved for ... \n--local ktsqdef = tmp:solve((k'_t'^2)())\n-- but instead I'll just do it by hand ...\nktsqdef = (tmp + k'_t'^2)():switch()\nprint(ktsqdef)\n;", output="${{{{ k} _a}} {{{ k} ^a}}} = {0}$<br>\n${{ k} ^a} = {{{{{ \\eta} ^a} ^b}} {{{ k} _b}}}$<br>\n${{{{ k} _a}} {{{{{{ \\eta} ^a} ^b}} {{{ k} _b}}}}} = {0}$<br>\n${{{{{ k} _t}} {{{{{{ \\eta} ^t} ^t}} {{{ k} _t}}}}} + {{{{ k} _i}} {{{{{{ \\eta} ^i} ^j}} {{{ k} _j}}}}}} = {0}$<br>\n${{{{ k} _i}^{2}} + {-{{{ k} _t}^{2}}}} = {0}$<br>\n${{-{{{ k} _t}^{2}}} + {\\left({\\sum_  i {{{ k} _i}^{2}}}\\right)}} = {0}$<br>\n${{ k} _t} = {\\sqrt{\\sum_  i {{{ k} _i}^{2}}}}$<br>\n${{{ k} _t}^{2}} = {{{ k} _i}^{2}}$<br>\n", outputtype="html", uid=131},
	{hidden=false, input="kDenseU = Tensor('^a', function(a) return k('^'..chart.coords[a].name) end)\nprint(k'^a':eq(kDenseU));", output="${{ k} ^a} = {\\overset{a\\downarrow}{\\left[ \\begin{matrix} { k} ^t \\\\ { k} ^x \\\\ { k} ^y \\\\ { k} ^z\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=36},
	{hidden=false, input="kDenseUFromL = kDenseL'^a'()\nkDenseUFromLDef = kDenseU:eq(kDenseUFromL)\nprint(k'^a':eq(kDenseUFromLDef));", output="${{ k} ^a} = {{\\overset{a\\downarrow}{\\left[ \\begin{matrix} { k} ^t \\\\ { k} ^x \\\\ { k} ^y \\\\ { k} ^z\\end{matrix} \\right]}} = {\\overset{a\\downarrow}{\\left[ \\begin{matrix} -{{ k} _t} \\\\ { k} _x \\\\ { k} _y \\\\ { k} _z\\end{matrix} \\right]}}}$<br>\n", outputtype="html", uid=34},
	{hidden=false, input="kUfromLdefs = kDenseUFromLDef:unravel()\nprint(kUfromLdefs:mapi(tostring):concat'<br>\\n');", output="${{ k} ^t} = {-{{ k} _t}}$<br>\n${{ k} ^x} = {{ k} _x}$<br>\n${{ k} ^y} = {{ k} _y}$<br>\n${{ k} ^z} = {{ k} _z}$<br>\n", outputtype="html", uid=38},
	{hidden=false, input="ktUfromLdef, kxUfromLdef, kyUfromLdef, kzUfromLdef = kUfromLdefs:unpack()", output="${{ k} ^t} = {-{{ k} _t}}$\9${{ k} ^x} = {{ k} _x}$\9${{ k} ^y} = {{ k} _y}$\9${{ k} ^z} = {{ k} _z}$", outputtype="html", uid=39},
	{hidden=false, input="-- expanded ...\nkexpdef = knulldef:replace(k'_a', kDenseL'_a')\n\9:replace(k'^a', kDenseU)()\n\9:subst(kUfromLdefs:unpack())()", output="${{{{ k} _z}^{2}} + {{{ k} _y}^{2}} + {{{{ k} _x}^{2}} + {-{{{ k} _t}^{2}}}}} = {0}$", outputtype="html", uid=23},
	{hidden=false, input="-- plus is first\nktLdefs = table{kexpdef:solve(k'_t')}\nprint(ktLdefs:mapi(tostring):concat'<br>\\n');", output="${{ k} _t} = {\\sqrt{{{{ k} _z}^{2}} + {{{ k} _x}^{2}} + {{{ k} _y}^{2}}}}$<br>\n${{ k} _t} = {-{\\sqrt{{{{ k} _z}^{2}} + {{{ k} _x}^{2}} + {{{ k} _y}^{2}}}}}$<br>\n", outputtype="html", uid=24},
	{hidden=false, input="ktUdefs = ktLdefs:mapi(function(def) return def:subst(ktUfromLdef:solve(k'_t')):solve(k'^t') end)\nktUdefs = ktUdefs:reverse() -- minus is first, so reverse it\nprint(ktUdefs:mapi(tostring):concat'<br>\\n');", output="${{ k} ^t} = {\\sqrt{{{{ k} _z}^{2}} + {{{ k} _x}^{2}} + {{{ k} _y}^{2}}}}$<br>\n${{ k} ^t} = {-{\\sqrt{{{{ k} _z}^{2}} + {{{ k} _x}^{2}} + {{{ k} _y}^{2}}}}}$<br>\n", outputtype="html", uid=37},
	{hidden=false, input="(A'_ua' * k'^a'):eq(0)", output="${{{{{ A} _u} _a}} {{{ k} ^a}}} = {0}$", outputtype="html", uid=17},
	{hidden=false, input="omega:eq(ktUdefs[1])", output="${\\omega} = {{{ k} ^t} = {\\sqrt{{{{ k} _z}^{2}} + {{{ k} _x}^{2}} + {{{ k} _y}^{2}}}}}$", outputtype="html", uid=18},
	{hidden=false, input="-- plane-wave vector:\nmvecdef = xi'^u':eq(-i * C'^u' * exp(i * k'_a' * x'^a'))", output="${{ \\xi} ^u} = { {-{i}} {{{ C} ^u}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}$", outputtype="html", uid=19},
	{hidden=false, input="-- section 4", output="", outputtype="html", uid=25},
	{hidden=false, input="Anulldef = (A'_uv' * u'^v'):eq(0)", output="${{{{{ A} _u} _v}} {{{ u} ^v}}} = {0}$", outputtype="html", uid=20},
	{hidden=false, input="A'^u_u':eq(A'_uv' * eta'^uv'):eq(0)", output="${{{{ A} ^u} _u} = {{{{{ A} _u} _v}} {{{{ \\eta} ^u} ^v}}}} = {0}$", outputtype="html", uid=21},
	{hidden=false, input="-- exercise 1 ... use u^0 = 1, u^i = 0, place in TT gauge, change hBar_uv to satisfy TT constraints, solve for C^u", output="", outputtype="html", uid=22},
	{hidden=false, input="ADenseLL = Tensor('_ab', function(a,b) if a > b then a,b = b,a end return A(' _'..chart.coords[a].name..' _'..chart.coords[b].name) end)\nprint(A'_uv':eq(ADenseLL));", output="${{{ A} _u} _v} = {\\overset{a\\downarrow b\\rightarrow}{\\left[ \\begin{matrix}  {{ A} _t} _t &  {{ A} _t} _x &  {{ A} _t} _y &  {{ A} _t} _z \\\\  {{ A} _t} _x &  {{ A} _x} _x &  {{ A} _x} _y &  {{ A} _x} _z \\\\  {{ A} _t} _y &  {{ A} _x} _y &  {{ A} _y} _y &  {{ A} _y} _z \\\\  {{ A} _t} _z &  {{ A} _x} _z &  {{ A} _y} _z &  {{ A} _z} _z\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=40},
	{hidden=false, input="-- ex 35.1 says to use this ... but I don't see where I need it ...\nuTimeDenseU = Tensor('^a', 1, 0, 0, 0)\nprint(u'^a':eq(uTimeDenseU));", output="${{ u} ^a} = {\\overset{a\\downarrow}{\\left[ \\begin{matrix} 1 \\\\ 0 \\\\ 0 \\\\ 0\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=41},
	{hidden=false, input="-- the first constraint: A_uv u^v = 0\nAnulldef:replace(A'_uv', ADenseLL'_uv'):replaceIndex(u'^a', uTimeDenseU'^a')()", output="${\\overset{u\\downarrow}{\\left[ \\begin{matrix} {{ A} _t} _t \\\\ {{ A} _t} _x \\\\ {{ A} _t} _y \\\\ {{ A} _t} _z\\end{matrix} \\right]}} = {0}$", outputtype="html", uid=26},
	{hidden=false, input="--[[\nwell, that's the result, so how do we get there?\nwe need to change our basis so that u^a = {1,0,0,0}\nour change-of-basis mechanism is x_new^u = x_old^u + xi^u\nand we want x_new^u to be [t,x,y,z] such that d/dt x_new^u = [1,0,0,0]\nwhich means xi^u = x_new^u - x_old^u = [t,x,y,z] - x_old^u\n\nand then we transform our de donder linearized weak limit gauge to one such that ...\nh_00 = h_0i = h_i0 = 0\nsum_k h_kk = 0\nsum_j h_kj,j = 0\nby h_00 = h_kk = 0 we get h^a_h = 0, and therefor h_ab = hbar_ab\n\nfrom there we impose 6 wave equations: h_jk,a^a = 0\nfrom there, we decompose any spatial tensor S^TT_ij = S^T_ij + S^L_ij\nwhere S^T_ij = 1/2 (δ_ij f_,kk - f_,ij) \"transverse\"\nand S^L_ij = 2 S^L_(i,j) \"longitudinal\" ... S^L_i is purely gauge\nso h^T_ij, h^TT_ij are gauge-invariant, and h^L_ij is purely gauge part\nand then somehow we get h_uv = h^TT_uv\n--]]", output="", outputtype="html", uid=42},
	{hidden=false, input="-- so now for problem 35.1, use these to create a TT metric (I think?  problem is worded vaguely)\nmwavecplxdef, ',', mvecdef, ',', hgaugechangedef", output="${{{ \\bar{h}} _u} _v} = {{{{{ A} _u} _v}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}$\9,\9${{ \\xi} ^u} = { {-{i}} {{{ C} ^u}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}$\9,\9${{{ {\\bar{h}_{{new}}}} _u} _v} = {{{{{ {\\bar{h}_{{old}}}} _u} _v} + {-{{{ \\xi} _u} _{,v}}}} + {-{{{ \\xi} _v} _{,u}}} + {{{{{ \\eta} _u} _v}} {{{{ \\xi} ^a} _{,a}}}}}$", outputtype="html", uid=75},
	{hidden=false, input="-- don't do exp(i theta) => cos(theta) + i sin(theta)\nsymmath.op.pow:pushRule'Prune/expToTheI'", output="", outputtype="html", uid=80},
	{hidden=false, input="mvecLdef = (mvecdef * eta'_uv'):simplifyMetrics():reindex{v='u'}", output="${{ \\xi} _u} = {{{-1}} {{i}} {{{ C} _u}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}$", outputtype="html", uid=79},
	{hidden=false, input="delta = Tensor:deltaSymbol()", output="$δ$", outputtype="html", uid=81},
	{hidden=false, input="hbarnewgaugedef = hgaugechangedef\n\9:replace(xi'^a_,a', xi'_a^,a')\n\9:splitOffDerivIndexes()\n\9:substIndex(mvecLdef)()\n\9--:replaceIndex(C'_u,v', 0)\n\9:replace(C'_u,v', 0)\n\9:replace(C'_v,u', 0)\n\9:replace(C'_a^,a', 0)()\n\9:replaceIndex(x'^b_,v', delta'^b_v')\n\9:replace(x'^b,a', eta'^ba') -- x^b,a = x^b_,c eta^ca = delta^b_c eta^ca = eta^ba\n\9:simplifyMetrics()\n\9-- is k_u constant?  it's the wave vector, so ... I guess so ?\n\9:replace(k'_b,u', 0)\n\9:replace(k'_b,v', 0)\n\9:replace(k'_b^,a', 0)()", output="${{{ {\\bar{h}_{{new}}}} _u} _v} = {{{{{{ {\\bar{h}_{{old}}}} _u} _v} + {-{{{{ C} _v}} {{{ k} _u}} {{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}}}}} + {-{{{{ C} _u}} {{{ k} _v}} {{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{ \\eta} _u} _v}} {{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}}}}$", outputtype="html", uid=76},
	{hidden=false, input="-- now use hbarolduv for our mwavecplxdef ...\nhbarnewgaugedef = hbarnewgaugedef:replace(hbarold, hbar)\n\9:subst(mwavecplxdef:reindex{a='b'})()", output="${{{ {\\bar{h}_{{new}}}} _u} _v} = {{{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}} {{\\left({{{{{{ A} _u} _v} + {-{{{{ C} _v}} {{{ k} _u}}}}} + {-{{{{ C} _u}} {{{ k} _v}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{ \\eta} _u} _v}}}}\\right)}}}$", outputtype="html", uid=85},
	{hidden=false, input="-- so somehow hbarnew needs to be TT, which means hbarnew_0u = 0, hbarnew_kk = 0, hbarnew_kj,j = 0 ...\n-- we are solving for C_u ... but k_u still must be arbitrary ...", output="", outputtype="html", uid=96},
	{hidden=false, input="-- so first try solving with indexes ...\nlocal constraint = hbarnew'_ti':eq(0)\nprint(constraint)\nhbar_0i_def = hbarnewgaugedef:reindex{uv='ti'}:subst(constraint)\nprint(hbar_0i_def)\nhbar_0i_def = hbar_0i_def:replace(eta'_ti', 0)\nCidef = hbar_0i_def:solve(C'_i')\nprint(Cidef)\n;", output="${{{ {\\bar{h}_{{new}}}} _t} _i} = {0}$<br>\n${0} = {{{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}} {{\\left({{{{{{ A} _t} _i} + {-{{{{ C} _i}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _i}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{ \\eta} _t} _i}}}}\\right)}}}$<br>\n${{ C} _i} = {\\frac{{{{ A} _t} _i} + {-{{{{ C} _t}} {{{ k} _i}}}}}{{ k} _t}}$<br>\n", outputtype="html", uid=129},
	{hidden=false, input="-- can we do the same thing with hbarnew'_tt'? no ...\nlocal constraint = hbarnew'_tt':eq(0)\nprint(constraint)\nlocal tmp = hbarnewgaugedef:reindex{uv='tt'}:subst(constraint)\nprint(tmp)\ntmp = tmp:replace(eta'_tt', -1)()\ntmp = (tmp / exp(i * k'_b' * x'^b'))()\ntmp = tmp:replace(C'_a' * k'^a', -C'_t' * k'_t' + C'_i' * k'_i')()\nprint(tmp)\n-- if I solve for C_t early then we can deduce a value ... though it is still based on C_i ...\n--print(tmp:solve(C'_t'))\n-- but as soon as we substitute our previous C_i def, the C_t def falls apart ...\ntmp = tmp:subst(Cidef)()\nprint(tmp)\ntmp = tmp:subst(ktsqdef)()\nprint(tmp)\n-- and now we're at A_tu k^u / k_t = 0 ... but A_tu k^u = 0 ... so this is just 0/k_t = 0, which is a given.\n-- so we don't learn anything new.", output="${{{ {\\bar{h}_{{new}}}} _t} _t} = {0}$<br>\n${0} = {{{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}} {{\\left({{{{{{ A} _t} _t} + {-{{{{ C} _t}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _t}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{ \\eta} _t} _t}}}}\\right)}}}$<br>\n${0} = {{{{{ A} _t} _t} + {-{{{{ C} _t}} {{{ k} _t}}}}} + {-{{{{ C} _i}} {{{ k} _i}}}}}$<br>\n${0} = {\\frac{{{{{ C} _t}} {{{{ k} _i}^{2}}}} + {{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ C} _t}} {{{{ k} _t}^{2}}}}}} + {-{{{{ k} _i}} {{{{ A} _t} _i}}}}}}{{ k} _t}}$<br>\n${0} = {\\frac{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ k} _i}} {{{{ A} _t} _i}}}}}{{ k} _t}}$<br>\n", outputtype="html", uid=130},
	{hidden=false, input="-- now I'm doing the same thing but with dense tensors ... maybe I can get rid of it\nCDenseL = Tensor('_a', function(a) return C('_'..chart.coords[a].name) end)\nprint(C'_a':eq(CDenseL));", output="${{ C} _a} = {\\overset{a\\downarrow}{\\left[ \\begin{matrix} { C} _t \\\\ { C} _x \\\\ { C} _y \\\\ { C} _z\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=87},
	{hidden=false, input="hbarnewdensegaugeLL = Tensor('_ab', \n\9{0, 0, 0, 0},\n\9{0, hbarnew'_xx', hbarnew'_xy', hbarnew'_xz'},\n\9{0, hbarnew'_xy', hbarnew'_yy', hbarnew'_yz'},\n\9{0, hbarnew'_xz', hbarnew'_yz', hbarnew'_zz'})\nprint(hbarnew'_uv':eq(hbarnewdensegaugeLL))\n-- ... subject still to hbarnew_kk=0, hbarnew_kj,j=0\n;", output="${{{ {\\bar{h}_{{new}}}} _u} _v} = {\\overset{a\\downarrow b\\rightarrow}{\\left[ \\begin{matrix}  0 &  0 &  0 &  0 \\\\  0 &  {{ {\\bar{h}_{{new}}}} _x} _x &  {{ {\\bar{h}_{{new}}}} _x} _y &  {{ {\\bar{h}_{{new}}}} _x} _z \\\\  0 &  {{ {\\bar{h}_{{new}}}} _x} _y &  {{ {\\bar{h}_{{new}}}} _y} _y &  {{ {\\bar{h}_{{new}}}} _y} _z \\\\  0 &  {{ {\\bar{h}_{{new}}}} _x} _z &  {{ {\\bar{h}_{{new}}}} _y} _z &  {{ {\\bar{h}_{{new}}}} _z} _z\\end{matrix} \\right]}}$<br>\n", outputtype="html", uid=88},
	{hidden=false, input="-- temp deferred\nthetadef = theta:eq(k'_b' * x'^b')", output="${\\theta} = {{{{ k} _b}} {{{ x} ^b}}}$", outputtype="html", uid=103},
	{hidden=false, input="-- dense?\nhbarnewgaugedensedef = hbarnewgaugedef\n\9:subst(thetadef:switch())\9-- don't replace these k's\n\9:replace(A, ADenseLL)\n\9:replace(k, kDenseL)\n\9:replace(eta, etaLLval)\n\9:replace(C, CDenseL)\n\9:replace(hbarnew, hbarnewdensegaugeLL)\n\9()", output="${\\overset{u\\downarrow v\\rightarrow}{\\left[ \\begin{matrix}  0 &  0 &  0 &  0 \\\\  0 &  {{ {\\bar{h}_{{new}}}} _x} _x &  {{ {\\bar{h}_{{new}}}} _x} _y &  {{ {\\bar{h}_{{new}}}} _x} _z \\\\  0 &  {{ {\\bar{h}_{{new}}}} _x} _y &  {{ {\\bar{h}_{{new}}}} _y} _y &  {{ {\\bar{h}_{{new}}}} _y} _z \\\\  0 &  {{ {\\bar{h}_{{new}}}} _x} _z &  {{ {\\bar{h}_{{new}}}} _y} _z &  {{ {\\bar{h}_{{new}}}} _z} _z\\end{matrix} \\right]}} = {\\overset{u\\downarrow v\\rightarrow}{\\left[ \\begin{matrix}  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{{{ A} _t} _t} + {-{{{{ C} _t}} {{{ k} _t}}}}} + {-{{{{ C} _x}} {{{ k} _x}}}}} + {-{{{{ C} _y}} {{{ k} _y}}}}} + {-{{{{ C} _z}} {{{ k} _z}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _t} _x} + {-{{{{ C} _x}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _x}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _t} _y} + {-{{{{ C} _y}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _y}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _t} _z} + {-{{{{ C} _z}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _z}}}}}\\right)}} \\\\  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _t} _x} + {-{{{{ C} _t}} {{{ k} _x}}}}} + {-{{{{ C} _x}} {{{ k} _t}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{ A} _x} _x} + {{{{ C} _z}} {{{ k} _z}}} + {{{{{{ C} _y}} {{{ k} _y}}} + {-{{{{ C} _x}} {{{ k} _x}}}}} + {-{{{{ C} _t}} {{{ k} _t}}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _x} _y} + {-{{{{ C} _y}} {{{ k} _x}}}}} + {-{{{{ C} _x}} {{{ k} _y}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _x} _z} + {-{{{{ C} _z}} {{{ k} _x}}}}} + {-{{{{ C} _x}} {{{ k} _z}}}}}\\right)}} \\\\  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _t} _y} + {-{{{{ C} _t}} {{{ k} _y}}}}} + {-{{{{ C} _y}} {{{ k} _t}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _x} _y} + {-{{{{ C} _x}} {{{ k} _y}}}}} + {-{{{{ C} _y}} {{{ k} _x}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{ A} _y} _y} + {{{{ C} _z}} {{{ k} _z}}} + {{{{{{ C} _x}} {{{ k} _x}}} + {-{{{{ C} _y}} {{{ k} _y}}}}} + {-{{{{ C} _t}} {{{ k} _t}}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _y} _z} + {-{{{{ C} _z}} {{{ k} _y}}}}} + {-{{{{ C} _y}} {{{ k} _z}}}}}\\right)}} \\\\  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _t} _z} + {-{{{{ C} _t}} {{{ k} _z}}}}} + {-{{{{ C} _z}} {{{ k} _t}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _x} _z} + {-{{{{ C} _x}} {{{ k} _z}}}}} + {-{{{{ C} _z}} {{{ k} _x}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{ A} _y} _z} + {-{{{{ C} _y}} {{{ k} _z}}}}} + {-{{{{ C} _z}} {{{ k} _y}}}}}\\right)}} &  {{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{ A} _z} _z} + {{{{ C} _y}} {{{ k} _y}}} + {{{{{{ C} _x}} {{{ k} _x}}} + {-{{{{ C} _z}} {{{ k} _z}}}}} + {-{{{{ C} _t}} {{{ k} _t}}}}}}\\right)}}\\end{matrix} \\right]}}$", outputtype="html", uid=86},
	{hidden=false, input="-- so now we have some constraints for A_tμ\nAttdef, Atxdef, Atydef, Atzdef = hbarnewgaugedensedef:unravel():sub(1,4) -- just use 1st 4 ... the other 3 are degen of it\n\9:mapi(function(eqn) return (eqn / exp(i * theta))() end):unpack() -- divide out the exp(iθ)\nprint(Attdef)\nprint(Atxdef)\nprint(Atydef)\nprint(Atzdef)\n;", output="${0} = {{{{{{{ A} _t} _t} + {-{{{{ C} _y}} {{{ k} _y}}}}} + {-{{{{ C} _x}} {{{ k} _x}}}}} + {-{{{{ C} _t}} {{{ k} _t}}}}} + {-{{{{ C} _z}} {{{ k} _z}}}}}$<br>\n${0} = {{{{{ A} _t} _x} + {-{{{{ C} _x}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _x}}}}}$<br>\n${0} = {{{{{ A} _t} _y} + {-{{{{ C} _y}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _y}}}}}$<br>\n${0} = {{{{{ A} _t} _z} + {-{{{{ C} _z}} {{{ k} _t}}}}} + {-{{{{ C} _t}} {{{ k} _z}}}}}$<br>\n", outputtype="html", uid=89},
	{hidden=false, input="Cxdef = Cidef:reindex{i='x'} --:subst(ktLdefs[1])", output="${{ C} _x} = {\\frac{{{{ A} _t} _x} + {-{{{{ C} _t}} {{{ k} _x}}}}}{{ k} _t}}$", outputtype="html", uid=90},
	{hidden=false, input="Cydef = Cidef:reindex{i='y'} --:subst(ktLdefs[1])", output="${{ C} _y} = {\\frac{{{{ A} _t} _y} + {-{{{{ C} _t}} {{{ k} _y}}}}}{{ k} _t}}$", outputtype="html", uid=91},
	{hidden=false, input="Czdef = Cidef:reindex{i='z'} --:subst(ktLdefs[1])", output="${{ C} _z} = {\\frac{{{{ A} _t} _z} + {-{{{{ C} _t}} {{{ k} _z}}}}}{{ k} _t}}$", outputtype="html", uid=92},
	{hidden=false, input="Ctdef = Attdef:solve(C'_t')\nprint(Ctdef)\nCtdef = Ctdef:subst(Cxdef, Cydef, Czdef):subst(ktLdefs[1]:switch())()\nprint(Ctdef)\nCtdef = Ctdef:solve(C'_t')\nprint(Ctdef)\n-- that looks nice ... C_t = A_tu k^u / k^u k_u ... except k^u k_u = 0 ... so .... try again\n;", output="${{ C} _t} = {\\frac{{{{{{ A} _t} _t} + {-{{{{ C} _x}} {{{ k} _x}}}}} + {-{{{{ C} _y}} {{{ k} _y}}}}} + {-{{{{ C} _z}} {{{ k} _z}}}}}{{ k} _t}}$<br>\n${{ C} _t} = {\\frac{{{{{ C} _t}} {{{{ k} _x}^{2}}}} + {{{{ C} _t}} {{{{ k} _z}^{2}}}} + {{{{ C} _t}} {{{{ k} _y}^{2}}}} + {{{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ k} _y}} {{{{ A} _t} _y}}}}} + {-{{{{ k} _x}} {{{{ A} _t} _x}}}}} + {-{{{{ k} _z}} {{{{ A} _t} _z}}}}}}{{{ k} _t}^{2}}}$<br>\n${{ C} _t} = {\\frac{{{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ k} _x}} {{{{ A} _t} _x}}}}} + {-{{{{ k} _z}} {{{{ A} _t} _z}}}}} + {-{{{{ k} _y}} {{{{ A} _t} _y}}}}}{{{{{{ k} _t}^{2}} + {-{{{ k} _x}^{2}}}} + {-{{{ k} _z}^{2}}}} + {-{{{ k} _y}^{2}}}}}$<br>\n", outputtype="html", uid=93},
	{hidden=false, input="Ctdef = Attdef:solve(C'_t') --:subst(ktLdefs[1])\nprint(Ctdef)\nCtdef = Ctdef:subst(Cxdef, Cydef, Czdef)()\nprint(Ctdef)\n--print(Ctdef:solve(C'_t'))\n--Ctdef = Ctdef:solve(C'_t') -- mustve returned null...\n--print(Ctdef)\n--Ctdef = Ctdef:subst(ktLdefs[1])()\n\nCtdef = (Ctdef * (k'_t'^2))()\n--Ctdef = (Ctdef * (k'_x'^2 + k'_y'^2 + k'_z'^2))()\nprint(Ctdef)\nCtdef = (Ctdef - C'_t' * (k'_x'^2 + k'_y'^2 + k'_z'^2))()\nprint(Ctdef)\n-- ....and now C_t is completely arbitrary ... subject to A_tu's constraints ... \n-- ... which I can reshape into our already-given constraints ...\nprint(Ctdef:subst(ktLdefs[1]:switch())())\n-- viola, A_tu k^u = 0, same as our constraint A_uv k^v = 0\n-- therefore we can't solve for C_t yet (right?)\n-- this is basically the last statement isn't it? just cross-multiply the denom=0 and get A_uv k^v = 0 ...\n;", output="${{ C} _t} = {\\frac{{{{{{ A} _t} _t} + {-{{{{ C} _x}} {{{ k} _x}}}}} + {-{{{{ C} _y}} {{{ k} _y}}}}} + {-{{{{ C} _z}} {{{ k} _z}}}}}{{ k} _t}}$<br>\n${{ C} _t} = {\\frac{{{{{ C} _t}} {{{{ k} _x}^{2}}}} + {{{{ C} _t}} {{{{ k} _z}^{2}}}} + {{{{ C} _t}} {{{{ k} _y}^{2}}}} + {{{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ k} _y}} {{{{ A} _t} _y}}}}} + {-{{{{ k} _x}} {{{{ A} _t} _x}}}}} + {-{{{{ k} _z}} {{{{ A} _t} _z}}}}}}{{{ k} _t}^{2}}}$<br>\n${{{{ C} _t}} {{{{ k} _t}^{2}}}} = {{{{{ C} _t}} {{{{ k} _x}^{2}}}} + {{{{ C} _t}} {{{{ k} _z}^{2}}}} + {{{{ C} _t}} {{{{ k} _y}^{2}}}} + {{{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ k} _y}} {{{{ A} _t} _y}}}}} + {-{{{{ k} _x}} {{{{ A} _t} _x}}}}} + {-{{{{ k} _z}} {{{{ A} _t} _z}}}}}}$<br>\n${{{{ C} _t}} {{\\left({{{{{{ k} _t}^{2}} + {-{{{ k} _x}^{2}}}} + {-{{{ k} _y}^{2}}}} + {-{{{ k} _z}^{2}}}}\\right)}}} = {{{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ k} _y}} {{{{ A} _t} _y}}}}} + {-{{{{ k} _x}} {{{{ A} _t} _x}}}}} + {-{{{{ k} _z}} {{{{ A} _t} _z}}}}}$<br>\n${{{{ C} _t}} {{\\left({{{{{{ k} _t}^{2}} + {-{{{ k} _y}^{2}}}} + {-{{{ k} _x}^{2}}}} + {-{{{ k} _z}^{2}}}}\\right)}}} = {{{{{{{ k} _t}} {{{{ A} _t} _t}}} + {-{{{{ k} _x}} {{{{ A} _t} _x}}}}} + {-{{{{ k} _y}} {{{{ A} _t} _y}}}}} + {-{{{{ k} _z}} {{{{ A} _t} _z}}}}}$<br>\n", outputtype="html", uid=95},
	{hidden=false, input="-- so here's our choice of C_u that transforms our hbarnew_uv such that hbarnew_0u = 0:\nCidef", output="${{ C} _i} = {\\frac{{{{ A} _t} _i} + {-{{{{ C} _t}} {{{ k} _i}}}}}{{ k} _t}}$", outputtype="html", uid=94},
	{hidden=false, input="-- next comes hbarnew_kk = 0 (to determine C_t)\nCtdef = (hbarnewgaugedensedef * etaUUval'^uv')()\nprint(Ctdef)\nprint(Ctdef[1]:eq(0))\nCtdef = Ctdef[2]:eq(0)\nprint(Ctdef)\nCtdef = Ctdef:subst(Cxdef, Cydef, Czdef, ktLdefs[1]:switch())\nprint(Ctdef)\nCtdef = (Ctdef() * k'_t' / exp(i * theta))()\nprint(Ctdef)\nCtdef = Ctdef:solve(C'_t') -- stalls if you don't massage the eqn with th previous 2 steps\nprint(Ctdef)\nCtdef = Ctdef:subst((ktLdefs[1]:switch()^2)())()\nprint(Ctdef)\n;", output="${{{{ {\\bar{h}_{{new}}}} _x} _x} + {{{ {\\bar{h}_{{new}}}} _y} _y} + {{{ {\\bar{h}_{{new}}}} _z} _z}} = {{{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{ A} _z} _z} + {{{ A} _y} _y} + {{{{ A} _x} _x} + {-{{{ A} _t} _t}}} + {{{2}} {{{ C} _z}} {{{ k} _z}}} + {{{2}} {{{ C} _x}} {{{ k} _x}}} + {{{{2}} {{{ C} _y}} {{{ k} _y}}} + {-{{{2}} {{{ C} _t}} {{{ k} _t}}}}}}\\right)}}}$<br>\n${{{{ {\\bar{h}_{{new}}}} _x} _x} + {{{ {\\bar{h}_{{new}}}} _y} _y} + {{{ {\\bar{h}_{{new}}}} _z} _z}} = {0}$<br>\n${{{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{ A} _z} _z} + {{{ A} _y} _y} + {{{{ A} _x} _x} + {-{{{ A} _t} _t}}} + {{{2}} {{{ C} _z}} {{{ k} _z}}} + {{{2}} {{{ C} _x}} {{{ k} _x}}} + {{{{2}} {{{ C} _y}} {{{ k} _y}}} + {-{{{2}} {{{ C} _t}} {{{ k} _t}}}}}}\\right)}}} = {0}$<br>\n${{{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{ A} _z} _z} + {{{ A} _y} _y} + {{{{ A} _x} _x} + {-{{{ A} _t} _t}}} + {{{2}} {{{ k} _z}} {{\\frac{{{{ A} _t} _z} + {-{{{{ C} _t}} {{{ k} _z}}}}}{{ k} _t}}}} + {{{2}} {{{ k} _x}} {{\\frac{{{{ A} _t} _x} + {-{{{{ C} _t}} {{{ k} _x}}}}}{{ k} _t}}}} + {{{{2}} {{{ k} _y}} {{\\frac{{{{ A} _t} _y} + {-{{{{ C} _t}} {{{ k} _y}}}}}{{ k} _t}}}} + {-{{{2}} {{{ C} _t}} {{{ k} _t}}}}}}\\right)}}} = {0}$<br>\n${{{{{ k} _t}} {{{{ A} _z} _z}}} + {{{{ k} _t}} {{{{ A} _y} _y}}} + {{{{ k} _t}} {{{{ A} _x} _x}}} + {{{2}} {{{ k} _y}} {{{{ A} _t} _y}}} + {{{2}} {{{ k} _x}} {{{{ A} _t} _x}}} + {{{{{{{{2}} {{{ k} _z}} {{{{ A} _t} _z}}} + {-{{{{ k} _t}} {{{{ A} _t} _t}}}}} + {-{{{2}} {{{ C} _t}} {{{{ k} _y}^{2}}}}}} + {-{{{2}} {{{ C} _t}} {{{{ k} _t}^{2}}}}}} + {-{{{2}} {{{ C} _t}} {{{{ k} _x}^{2}}}}}} + {-{{{2}} {{{ C} _t}} {{{{ k} _z}^{2}}}}}}} = {0}$<br>\n${{ C} _t} = {\\frac{{{{{ k} _t}} {{{{ A} _x} _x}}} + {{{{ k} _t}} {{{{ A} _y} _y}}} + {{{{ k} _t}} {{{{ A} _z} _z}}} + {{{2}} {{{ k} _x}} {{{{ A} _t} _x}}} + {{{2}} {{{ k} _y}} {{{{ A} _t} _y}}} + {{{{2}} {{{ k} _z}} {{{{ A} _t} _z}}} + {-{{{{ k} _t}} {{{{ A} _t} _t}}}}}}{{{2}} {{\\left({{{{ k} _x}^{2}} + {{{ k} _y}^{2}} + {{{ k} _t}^{2}} + {{{ k} _z}^{2}}}\\right)}}}}$<br>\n${{ C} _t} = {\\frac{{{{{ k} _t}} {{{{ A} _x} _x}}} + {{{{ k} _t}} {{{{ A} _z} _z}}} + {{{{ k} _t}} {{{{ A} _y} _y}}} + {{{2}} {{{ k} _y}} {{{{ A} _t} _y}}} + {{{2}} {{{ k} _x}} {{{{ A} _t} _x}}} + {{{{2}} {{{ k} _z}} {{{{ A} _t} _z}}} + {-{{{{ k} _t}} {{{{ A} _t} _t}}}}}}{{{4}} {{{{ k} _t}^{2}}}}}$<br>\n", outputtype="html", uid=99},
	{hidden=false, input="AdotKeq0 = (A'_uv' * k'^v'):eq(0)\nprint(AdotKeq0)\nAdotKeq0dense = AdotKeq0:replace(A, ADenseLL):replace(k, kDenseUFromL):replace(0, Tensor'_u')()\nprint(AdotKeq0dense)\nAtdotKeq0, AxdotKeq0, AydotKeq0, AzdotKeq0 = AdotKeq0dense:unravel():unpack()\nprint(AtdotKeq0)\nprint(AxdotKeq0)\nprint(AydotKeq0)\nprint(AzdotKeq0)\n;", output="${{{{{ A} _u} _v}} {{{ k} ^v}}} = {0}$<br>\n${\\overset{u\\downarrow}{\\left[ \\begin{matrix} {{{{ k} _z}} {{{{ A} _t} _z}}} + {{{{ k} _x}} {{{{ A} _t} _x}}} + {{{{{ k} _y}} {{{{ A} _t} _y}}} + {-{{{{ k} _t}} {{{{ A} _t} _t}}}}} \\\\ {{{{ k} _z}} {{{{ A} _x} _z}}} + {{{{ k} _x}} {{{{ A} _x} _x}}} + {{{{{ k} _y}} {{{{ A} _x} _y}}} + {-{{{{ k} _t}} {{{{ A} _t} _x}}}}} \\\\ {{{{ k} _z}} {{{{ A} _y} _z}}} + {{{{ k} _x}} {{{{ A} _x} _y}}} + {{{{{ k} _y}} {{{{ A} _y} _y}}} + {-{{{{ k} _t}} {{{{ A} _t} _y}}}}} \\\\ {{{{ k} _z}} {{{{ A} _z} _z}}} + {{{{ k} _x}} {{{{ A} _x} _z}}} + {{{{{ k} _y}} {{{{ A} _y} _z}}} + {-{{{{ k} _t}} {{{{ A} _t} _z}}}}}\\end{matrix} \\right]}} = {\\overset{u\\downarrow}{\\left[ \\begin{matrix} 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{matrix} \\right]}}$<br>\n${{{{{ k} _z}} {{{{ A} _t} _z}}} + {{{{ k} _x}} {{{{ A} _t} _x}}} + {{{{{ k} _y}} {{{{ A} _t} _y}}} + {-{{{{ k} _t}} {{{{ A} _t} _t}}}}}} = {0}$<br>\n${{{{{ k} _z}} {{{{ A} _x} _z}}} + {{{{ k} _x}} {{{{ A} _x} _x}}} + {{{{{ k} _y}} {{{{ A} _x} _y}}} + {-{{{{ k} _t}} {{{{ A} _t} _x}}}}}} = {0}$<br>\n${{{{{ k} _z}} {{{{ A} _y} _z}}} + {{{{ k} _x}} {{{{ A} _x} _y}}} + {{{{{ k} _y}} {{{{ A} _y} _y}}} + {-{{{{ k} _t}} {{{{ A} _t} _y}}}}}} = {0}$<br>\n${{{{{ k} _z}} {{{{ A} _z} _z}}} + {{{{ k} _x}} {{{{ A} _x} _z}}} + {{{{{ k} _y}} {{{{ A} _y} _z}}} + {-{{{{ k} _t}} {{{{ A} _t} _z}}}}}} = {0}$<br>\n", outputtype="html", uid=101},
	{hidden=false, input="AdotKsqeq0 = (A'_uv' * k'^u' * k'^v'):eq(0)\nprint(AdotKsqeq0)\nAdotKsqeq0dense = AdotKsqeq0:replace(A, ADenseLL):replace(k, kDenseUFromL)()\nprint(AdotKsqeq0dense)\n;", output="${{{{{ A} _u} _v}} {{{ k} ^u}} {{{ k} ^v}}} = {0}$<br>\n${{{{{{ A} _t} _t}} {{{{ k} _t}^{2}}}} + {{{{{ A} _z} _z}} {{{{ k} _z}^{2}}}} + {{{{{ A} _x} _x}} {{{{ k} _x}^{2}}}} + {{{{{ A} _y} _y}} {{{{ k} _y}^{2}}}} + {{{2}} {{{ k} _y}} {{{ k} _z}} {{{{ A} _y} _z}}} + {{{2}} {{{ k} _x}} {{{ k} _z}} {{{{ A} _x} _z}}} + {{{{{{2}} {{{ k} _x}} {{{ k} _y}} {{{{ A} _x} _y}}} + {-{{{2}} {{{ k} _t}} {{{ k} _y}} {{{{ A} _t} _y}}}}} + {-{{{2}} {{{ k} _t}} {{{ k} _x}} {{{{ A} _t} _x}}}}} + {-{{{2}} {{{ k} _t}} {{{ k} _z}} {{{{ A} _t} _z}}}}}} = {0}$<br>\n", outputtype="html", uid=111},
	{hidden=false, input="Ctdef = (Ctdef - AtdotKeq0:switch() / (2 * k'_t'^2))()", output="${{ C} _t} = {\\frac{{{{ A} _t} _t} + {{{ A} _x} _x} + {{{ A} _z} _z} + {{{ A} _y} _y}}{{{4}} {{{ k} _t}}}}$", outputtype="html", uid=102},
	{hidden=false, input="Ctindexdef = Ctdef:replace(A'_xx' + A'_yy' + A'_zz', A'_kk')", output="${{ C} _t} = {\\frac{{{{ A} _t} _t} + {{{ A} _k} _k}}{{{4}} {{{ k} _t}}}}$", outputtype="html", uid=117},
	{hidden=false, input="xDenseU = Tensor('^a', chart.coords:unpack())", output="$\\overset{a\\downarrow}{\\left[ \\begin{matrix} t \\\\ x \\\\ y \\\\ z\\end{matrix} \\right]}$", outputtype="html", uid=104},
	{hidden=false, input="--[[\n-- Alright, from hbar_0u = 0 we got C_i, and from hbar_kk = 0 we got C_0 ... now what about the final constraint, hbar_ij,j = 0?\n-- how about looking at what the new hbar_uv looks like?\ntmp = hbarnewgaugedensedef:subst(Cxdef, Cydef, Czdef, Ctdef)()\n-- it's ugly.\n--]]", output="", outputtype="html", uid=105},
	{hidden=false, input="--[[\n-- don't forget to use our constraints ... A_uv k^v = 0 ...\ntmp[2][1][1] = (tmp[2][1][1] + exp(i * theta) * AtdotKeq0[1] / k'_t')():subst(ktLdefs[1])()\ntmp[2][2][2] = (tmp[2][2][2] - exp(i * theta) * AtdotKeq0[1] / k'_t')():subst((ktLdefs[1]^2)())()\ntmp[2][3][3] = (tmp[2][3][3] - exp(i * theta) * AtdotKeq0[1] / k'_t')():subst((ktLdefs[1]^2)())()\ntmp[2][4][4] = (tmp[2][4][4] - exp(i * theta) * AtdotKeq0[1] / k'_t')():subst((ktLdefs[1]^2)())()\nprint(tmp);\n-- still ugly.\n--]]", output="", outputtype="html", uid=108},
	{hidden=false, input="theta:setDependentVars(chart.coords:unpack())", output="", outputtype="html", uid=113},
	{hidden=false, input="hbarnewgaugedef", output="${{{ {\\bar{h}_{{new}}}} _u} _v} = {{{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}} {{\\left({{{{{{ A} _u} _v} + {-{{{{ C} _v}} {{{ k} _u}}}}} + {-{{{{ C} _u}} {{{ k} _v}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{ \\eta} _u} _v}}}}\\right)}}}$", outputtype="html", uid=119},
	{hidden=false, input="-- I think this is easier to do in index form ...\nhbarnewgaugespatialdef = hbarnewgaugedef\n\9:subst(thetadef:switch())\n\9:reindex{uv='ij'}'_,j'()", output="${{{{ {\\bar{h}_{{new}}}} _i} _j} _{,j}} = {{{\\exp\\left({{{i}} {{\\theta}}}\\right)}} {{\\left({{{{{{{{{ A} _i} _j} _{,j}} + {-{{{{ C} _i}} {{{{ k} _j} _{,j}}}}}} + {-{{{{ C} _j}} {{{{ k} _i} _{,j}}}}}} + {-{{{{ k} _j}} {{{{ C} _i} _{,j}}}}}} + {-{{{{ k} _i}} {{{{ C} _j} _{,j}}}}}} + {{{i}} {{{ \\theta} _{,j}}} {{{{ A} _i} _j}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{{ \\eta} _i} _j} _{,j}}}} + {{{{ C} _a}} {{{{ \\eta} _i} _j}} {{{{ k} ^a} _{,j}}}} + {{{{{{ k} ^a}} {{{{ C} _a} _{,j}}} {{{{ \\eta} _i} _j}}} + {-{{{i}} {{{ C} _j}} {{{ k} _i}} {{{ \\theta} _{,j}}}}}} + {-{{{i}} {{{ C} _i}} {{{ k} _j}} {{{ \\theta} _{,j}}}}}} + {{{i}} {{{ C} _a}} {{{ k} ^a}} {{{ \\theta} _{,j}}} {{{{ \\eta} _i} _j}}}}\\right)}}}$", outputtype="html", uid=112},
	{hidden=false, input="hbarnewgaugespatialdef = hbarnewgaugespatialdef\n\9:subst(thetadef)()", output="${{{{ {\\bar{h}_{{new}}}} _i} _j} _{,j}} = {{{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}} {{\\left({{{{{{{{{ A} _i} _j} _{,j}} + {-{{{{ C} _j}} {{{{ k} _i} _{,j}}}}}} + {-{{{{ C} _i}} {{{{ k} _j} _{,j}}}}}} + {-{{{{ k} _i}} {{{{ C} _j} _{,j}}}}}} + {-{{{{ k} _j}} {{{{ C} _i} _{,j}}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{{ \\eta} _i} _j} _{,j}}}} + {{{{ C} _a}} {{{{ \\eta} _i} _j}} {{{{ k} ^a} _{,j}}}} + {{{{ k} ^a}} {{{{ C} _a} _{,j}}} {{{{ \\eta} _i} _j}}} + {{{i}} {{{ k} _b}} {{{{ A} _i} _j}} {{{{ x} ^b} _{,j}}}} + {{{{{{{i}} {{{ x} ^b}} {{{{ A} _i} _j}} {{{{ k} _b} _{,j}}}} + {-{{{i}} {{{ C} _j}} {{{ k} _b}} {{{ k} _i}} {{{{ x} ^b} _{,j}}}}}} + {-{{{i}} {{{ C} _j}} {{{ k} _i}} {{{ x} ^b}} {{{{ k} _b} _{,j}}}}}} + {-{{{i}} {{{ C} _i}} {{{ k} _j}} {{{ x} ^b}} {{{{ k} _b} _{,j}}}}}} + {-{{{i}} {{{ C} _i}} {{{ k} _b}} {{{ k} _j}} {{{{ x} ^b} _{,j}}}}}} + {{{i}} {{{ C} _a}} {{{ k} ^a}} {{{ k} _b}} {{{{ \\eta} _i} _j}} {{{{ x} ^b} _{,j}}}} + {{{i}} {{{ C} _a}} {{{ k} ^a}} {{{ x} ^b}} {{{{ \\eta} _i} _j}} {{{{ k} _b} _{,j}}}}}\\right)}}}$", outputtype="html", uid=118},
	{hidden=false, input="hbarnewgaugespatialdef = hbarnewgaugespatialdef\n\9:replace(A'_ij,j', 0)\9-- A_uv is constant wrt x, right?  it's the wave amplitude, so ...\n\9:replace(k'_j,j', 0)\9-- k_u is constant wrt x too, right?\n\9:replace(k'_i,j', 0)\n\9:replace(k'_b,j', 0)\n\9:replace(x'^b_,j', delta'^b_j')\n\9:replace(k'^a_,j', 0)\n\9:replace(C'_i,j', 0)\9-- and C is based on A and k, so it's constant too right?\n\9:replace(C'_j,j', 0)\n\9:replace(C'_a,j', 0)\n\9:replace(eta'_ij,j', 0)\n\9():simplifyMetrics()()", output="${{{{ {\\bar{h}_{{new}}}} _i} _j} _{,j}} = {{{i}} {{{ k} _j}} {{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}} {{\\left({{{{{{ A} _i} _j} + {-{{{{ C} _i}} {{{ k} _j}}}}} + {-{{{{ C} _j}} {{{ k} _i}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{ \\eta} _i} _j}}}}\\right)}}}$", outputtype="html", uid=114},
	{hidden=false, input="hbarnewgaugedef:reindex{uv='ij'}:switch()", output="${{{\\exp\\left({{{i}} {{{ k} _b}} {{{ x} ^b}}}\\right)}} {{\\left({{{{{{ A} _i} _j} + {-{{{{ C} _j}} {{{ k} _i}}}}} + {-{{{{ C} _i}} {{{ k} _j}}}}} + {{{{ C} _a}} {{{ k} ^a}} {{{{ \\eta} _i} _j}}}}\\right)}}} = {{{ {\\bar{h}_{{new}}}} _i} _j}$", outputtype="html", uid=120},
	{hidden=false, input="hbarnewgaugespatialdef = hbarnewgaugespatialdef\n\9:subst(hbarnewgaugedef:reindex{uv='ij'}:switch()())\n\9()", output="${{{{ {\\bar{h}_{{new}}}} _i} _j} _{,j}} = {{{i}} {{{ k} _j}} {{{{ {\\bar{h}_{{new}}}} _i} _j}}}$", outputtype="html", uid=116},
	{hidden=false, input="mwavecplxdef", output="${{{ \\bar{h}} _u} _v} = {{{{{ A} _u} _v}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}$", outputtype="html", uid=122},
	{hidden=false, input="Anew = var'A_{new}'", output="${A_{{new}}}$", outputtype="html", uid=123},
	{hidden=false, input="mwavecplxnewdef = mwavecplxdef:replace(hbar, hbarnew):replace(A, Anew)", output="${{{ {\\bar{h}_{{new}}}} _u} _v} = {{{{{ {A_{{new}}}} _u} _v}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}$", outputtype="html", uid=121},
	{hidden=false, input="hbarnewgaugespatialdef:subst(mwavecplxnewdef:reindex{uv='ij'})", output="${{{{ {\\bar{h}_{{new}}}} _i} _j} _{,j}} = {{{i}} {{{ k} _j}} {{{{{{ {A_{{new}}}} _i} _j}} {{\\exp\\left({{{i}} {{{ k} _a}} {{{ x} ^a}}}\\right)}}}}}$", outputtype="html", uid=124},
	{hidden=false, input="-- and then I say A_ij k_j = 0, therefore hbarnew_ij,j = 0\n-- but I didn't show Anew_ij k_j = 0 ... so TODO that I guess", output="", outputtype="html", uid=125},
	{hidden=false, input="-- but now on to exercise 35.2 ...\n-- which seems to be about spherical coordinate application of de-donder gauge weak-field limit\n-- (which itself depends on a constant background metric, so can't be applied to spherical up front)", output="", outputtype="html", uid=126},
	{hidden=false, input="-- now 35.3", output="", outputtype="html", uid=127},
	{hidden=false, input="-- when we're done ...\n--symmath.op.pow:popRule'Prune/expToTheI'", output="", outputtype="html", uid=78}
}