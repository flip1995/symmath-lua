Symbolic Math library for Lua

Goals:

- Everything done in pure Lua / Lua syntax.  No/minimal parsing.
- Originally intended for computational physics.  Implement equations in Lua, perform symbolic manipulation, generate functions (via symmath.compile)

Online demo and API at http://christopheremoore.net/symbolic-lua
Example used at http://christopheremoore.net/metric
	and http://christopheremoore.net/gravitational-wave-simulation


TODO


- solving equalities
- integrals.  symbolic, numeric explicit, then eventually get to numeric implicit (this involves derivatives based on both the dependent and the state variable)

- functions that lua has that I don't: abs, ceil, floor, deg, rad, fmod, frexp, log10, min, max

- support for numbers rather than only Constant

- integrate with lua-parser to decompile lua code -> ast -> symmath, perform symbolic differentiation on it, then recompile it ...
	i.e. f = [[function(x) return x^2 end]] g = symmath:luaDiff(f, 'x') <=> g = [[function(x) return 2*x end]]


NOTES TO SELF

representation and order of operations:

simplify(): div add mul
expand(): add div mul
factor(): mul add div
factorDivision(): add mul div

hmm, here's a though ... define the rules that exchange precedence (i.e. div add <=> add div, etc)
and then define the commands by their precedence (i.e. simplify: div, add, mul; expand: add, div, mul)
then making new arrangements of precendence and adding new operations would be easier

then I'd still have to define exchange rules for each pair of operations: add, mul, div, pow
so all in all: add<=>mul, add<=>div, add<=>pow, mul<=>div, mul<=>pow, div<=>pow

examples of exchange rules:

div add => add div: (a+b)/c => a/c + b/c
	if divOp.is(expr) and addOp.is(expr[1]) then
		local results = expr[1][1]:clone() / expr[2]:clone + expr[1][2]:clone() / expr[2]:clone()
		if #expr[1] > 2 then
			results = sum(results, table.unpack(expr[1], 3))
		end
		return apply(results)
	end

add div => div add: a/b + c1 + c2 + ... + cn => (a + b c1 + b c2 + ... + b cn)/b 
	if addOp.is(expr) then
		for i=1,#expr do
			if divOp.is(expr[i]) then
				return apply(sum(range(#expr):map(function(j)
					if i ~= j then
						return expr[i][2]:clone() * expr[j]
					else
						return expr[i][1]:clone()
					end
				end):unpack()) / expr[i][2]:clone())
			end
		end
	end
